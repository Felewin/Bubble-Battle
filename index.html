<html><head><base href="https://bubblebattle.ocean/">
<title>Bubble Battle - Underwater Strategy</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: linear-gradient(135deg, #0077be, #00305a);
    color: #fff;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  #backgroundCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  #uiCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .bubble {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.3);
    cursor: default;
    transition: transform 0.3s ease, opacity 0.3s ease, background 1s ease;
    opacity: 0.8;
  }
  .bubble.player1 {
    cursor: pointer;
  }
  .bubble.player1:hover {
    transform: scale(1.02);
    opacity: 1;
  }
  .player1 { background: radial-gradient(circle at 30% 30%, #7fff7f, #00a000); }
  .player2 { background: radial-gradient(circle at 30% 30%, #ff69b4, #c71585); }
  .neutral { background: radial-gradient(circle at 30% 30%, #b0e0e6, #4682b4); }
  .neutral.empty { background: radial-gradient(circle at 30% 30%, #f0f0f0, #c0c0c0); }
  .turret {
    position: absolute;
    border-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.3);
    cursor: default;
    transition: transform 0.3s ease, opacity 0.3s ease, background 1s ease;
    opacity: 0.8;
    border: 3px solid rgba(255, 255, 255, 0.4);
  }
  .turret.player1 {
    cursor: pointer;
  }
  .turret.player1:hover {
    transform: scale(1.02);
    opacity: 1;
  }
  .turret.neutral { background: linear-gradient(135deg, #666 25%, #888 25%, #888 50%, #666 50%, #666 75%, #888 75%, #888); }
  .turret.neutral.empty { background: linear-gradient(135deg, #d0d0d0 25%, #f0f0f0 25%, #f0f0f0 50%, #d0d0d0 50%, #d0d0d0 75%, #f0f0f0 75%, #f0f0f0); }
  .turret.player1 { background: linear-gradient(135deg, #00a000 25%, #00d000 25%, #00d000 50%, #00a000 50%, #00a000 75%, #00d000 75%, #00d000); }
  .turret.player2 { background: linear-gradient(135deg, #c71585 25%, #ff69b4 25%, #ff69b4 50%, #c71585 50%, #c71585 75%, #ff69b4 75%, #ff69b4); }
  .zapper {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.3);
    cursor: default;
    transition: transform 0.3s ease, opacity 0.3s ease, background 1s ease;
    opacity: 0.8;
    border: 3px solid rgba(255, 255, 255, 0.4);
  }
  .zapper.player1 {
    cursor: pointer;
  }
  .zapper.player1:hover {
    transform: scale(1.02);
    opacity: 1;
  }
  .zapper.neutral { background: repeating-linear-gradient(45deg, #666 0px, #666 4px, #888 4px, #888 8px); }
  .zapper.neutral.empty { background: repeating-linear-gradient(45deg, #d0d0d0 0px, #d0d0d0 4px, #f0f0f0 4px, #f0f0f0 8px); }
  .zapper.player1 { background: repeating-linear-gradient(45deg, #00a000 0px, #00a000 4px, #00d000 4px, #00d000 8px); }
  .zapper.player2 { background: repeating-linear-gradient(45deg, #c71585 0px, #c71585 4px, #ff69b4 4px, #ff69b4 8px); }
  @keyframes shipSpawn {
    0% {
      transform: scale(0);
    }
    50% {
      transform: scale(1.3);
    }
    65% {
      transform: scale(0.9);
    }
    80% {
      transform: scale(1.1);
    }
    90% {
      transform: scale(0.95);
    }
    100% {
      transform: scale(1);
    }
  }
  .microBubble {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.9);
    animation: shipSpawn 0.5s ease-out;
  }
  #victoryScreen, #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #victoryMessage, #gameTitle {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px #00ff00;
    margin-bottom: 30px;
  }
  .gameButton {
    font-size: 24px;
    padding: 10px 20px;
    background-color: #00a000;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 10px;
  }
  .gameButton:hover {
    background-color: #00c000;
    transform: scale(1.1);
  }
  #controlsExplanation {
    max-width: 600px;
    text-align: center;
    margin-bottom: 30px;
    font-size: 18px;
    line-height: 1.5;
  }


  #menuButtons {
    display: flex;
    gap: 15px;
    justify-content: center;
  }
</style>
</head>
<body>
<canvas id="backgroundCanvas"></canvas>
<canvas id="gameCanvas"></canvas>
<canvas id="uiCanvas"></canvas>
<audio id="sendSound" src="bubble_release.wav"></audio>
<audio id="captureSound" src="bubble_pop.wav"></audio>
<div id="startScreen" style="display: none;">
  <h1 id="gameTitle">Bubble Battle</h1>
  <div id="controlsExplanation">
    <p><strong>Left Click Drag:</strong> Smart send to capture enemy bases</p>
    <p><strong>Middle Click Drag:</strong> Establish vassal relationship or send 50%</p>
    <p><strong>Right Click Drag:</strong> Send 100% - 1 ships</p>
    <p><strong>Spacebar (over planet):</strong> Diaspora - smart send to all 0-ship bases</p>
    <p><strong>Mouse Wheel (over vassal):</strong> Adjust vassal minimum ships</p>
  </div>
  <div id="menuButtons">
    <button id="startGameButton" class="gameButton">Resume Game</button>
    <button id="pauseRestartButton" class="gameButton">Restart Map</button>
  </div>
</div>
<div id="victoryScreen" style="display: none;">
  <div id="victoryMessage">Victory!</div>
  <button id="restartButton" class="gameButton">Restart</button>
  <button id="newGameButton" class="gameButton">New Game</button>
</div>
<script>
const backgroundCanvas = document.getElementById('backgroundCanvas');
const backgroundCtx = backgroundCanvas.getContext('2d');
const gameCanvas = document.getElementById('gameCanvas');
const gameCtx = gameCanvas.getContext('2d');
const uiCanvas = document.getElementById('uiCanvas');
const uiCtx = uiCanvas.getContext('2d');
const sendSound = document.getElementById('sendSound');
const captureSound = document.getElementById('captureSound');
const victoryScreen = document.getElementById('victoryScreen');
const startScreen = document.getElementById('startScreen');
const newGameButton = document.getElementById('newGameButton');
const restartButton = document.getElementById('restartButton');
const startGameButton = document.getElementById('startGameButton');
const pauseRestartButton = document.getElementById('pauseRestartButton');

backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;

let bubbles = [];
let microBubbles = [];
let dragStartBubble = null;
let dragEndPos = null;
let plankton = [];
let isDraggingRightClick = false;
let gameSessionId = 0; // Incremented on restart to cancel ongoing ship launches
let isDraggingMiddleClick = false;
let gameState = [];
let turretState = [];
let zapperState = null; // Store zapper data for map restarts
let gameStarted = true;
let startScreenBubbles = [];
let hoveredBubble = null;
let passiveEnemiesMode = false;
let nebulae = [];
let shootingStars = [];
let shootingStarDirection = 0; // Direction for this map (0-3: top, right, bottom, left)
let laserTurrets = []; // Square defensive structures
let activeLasers = []; // Currently firing laser beams (for visual effect)
let zappers = []; // Zapper structures that fire lasers
let squadronDestroyedCount = new Map(); // Track destroyed ships per squadron
let squadronOriginalSizes = new Map(); // Track original size of each squadron
let activeSquadronLaunches = new Map(); // Track active squadron launches: squadronId -> owner
let debrisParticles = []; // Particles for ownership change effect
let pirateRaids = []; // Active pirate raid ships
let lastPirateSpawn = Date.now();
let nextPirateInterval = 5000 + Math.random() * 25000; // 5s to 30s
let lastFrameTime = Date.now();
let lastShootingStarTime = Date.now();
let mouseX = 0;
let mouseY = 0;

const SHIP_SPEED = 75; // pixels per second (doubled from 37.5)
const SHIP_RADIUS = 3; // Radius of the ship (half of its width)
const SHIP_RELEASE_DELAY = (SHIP_RADIUS * 2 / SHIP_SPEED) * 1000 * 1.5; // 1.5 times longer delay between ship releases

function createTurret(x, y, size, fireRange = null, microBubbles = null, owner = 'neutral') {
  const turret = document.createElement('div');
  turret.style.left = `${x}px`;
  turret.style.top = `${y}px`;
  turret.style.width = `${size}px`;
  turret.style.height = `${size}px`;
  turret.microBubbles = microBubbles !== null ? microBubbles : Math.floor(Math.random() * 30); // Same as neutral planets: 0-29 ships
  
  // Set class with "empty" suffix if turret has 0 ships
  turret.className = `turret ${owner}` + (turret.microBubbles === 0 && owner === 'neutral' ? ' empty' : '');
  turret.lastLaserFire = 0;
  turret.isTurret = true; // Mark as turret
  turret.lastGrowth = Date.now(); // For consistency, though turrets don't grow
  turret.lastAttackTime = 0; // For enemy AI cooldown tracking
  
  // Random fire range: 1x to 2x max planet size (396 to 792 pixels), or use provided value
  const maxPlanetSize = 99 * 4; // 396
  turret.fireRange = fireRange !== null ? fireRange : maxPlanetSize * (1 + Math.random()); // 396 to 792
  
  // Create count display like bubbles have
  const countDisplay = document.createElement('div');
  countDisplay.textContent = turret.microBubbles;
  countDisplay.style.position = 'relative';
  countDisplay.style.zIndex = '1';
  turret.appendChild(countDisplay);
  turret.countDisplay = countDisplay;
  
  // Create overlay element for showing required ships
  const overlay = document.createElement('div');
  overlay.className = 'turret-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '-20px';
  overlay.style.left = '50%';
  overlay.style.transform = 'translateX(-50%)';
  overlay.style.fontSize = '16px';
  overlay.style.fontWeight = 'bold';
  overlay.style.color = '#fff';
  overlay.style.textShadow = '0 0 5px rgba(0, 0, 0, 0.8)';
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = '10';
  turret.appendChild(overlay);
  turret.overlay = overlay;
  
  const fontSize = Math.max(12, Math.min(24, size / 4));
  turret.style.fontSize = `${fontSize}px`;
  
  // Add mouse event listeners for sending ships (check ownership when clicked)
  turret.addEventListener('mousedown', (e) => {
    // Only allow dragging if turret is owned by player at the time of click
    if (turret.className.includes('player1')) {
      if (e.button === 0) {
        dragStartBubble = turret;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
      } else if (e.button === 2) {
        dragStartBubble = turret;
        isDraggingRightClick = true;
        isDraggingMiddleClick = false;
      } else if (e.button === 1) {
        dragStartBubble = turret;
        isDraggingMiddleClick = true;
        isDraggingRightClick = false;
      }
    }
  });
  
  document.body.appendChild(turret);
  laserTurrets.push(turret);
}

function createZapper(x, y, size, microBubbles = null, owner = 'neutral', fireRange = null) {
  const zapper = document.createElement('div');
  zapper.style.left = `${x}px`;
  zapper.style.top = `${y}px`;
  zapper.style.width = `${size}px`;
  zapper.style.height = `${size}px`;
  zapper.style.position = 'absolute';
  zapper.style.borderRadius = '50%';
  zapper.microBubbles = microBubbles !== null ? microBubbles : Math.floor(Math.random() * 30); // 0-29 ships

  // Set class with "empty" suffix if zapper has 0 ships
  zapper.className = `zapper ${owner}` + (zapper.microBubbles === 0 && owner === 'neutral' ? ' empty' : '');
  zapper.isZapper = true;
  zapper.lastGrowth = Date.now();
  zapper.lastAttackTime = 0;
  zapper.lastZapperFire = 0; // For once per second firing

  // Random fire range: 1x to 2x max planet size (396 to 792 pixels), or use provided value
  const maxPlanetSize = 99 * 4; // 396
  zapper.fireRange = fireRange !== null ? fireRange : maxPlanetSize * (1 + Math.random()); // 396 to 792

  // Zapper visual styling (handled by CSS classes)
  zapper.style.transition = 'background 1s ease';

  // Create count display
  const countDisplay = document.createElement('div');
  countDisplay.textContent = zapper.microBubbles;
  countDisplay.style.position = 'relative';
  countDisplay.style.zIndex = '1';
  zapper.appendChild(countDisplay);
  zapper.countDisplay = countDisplay;

  // Create overlay element for showing required ships
  const overlay = document.createElement('div');
  overlay.className = 'zapper-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '-20px';
  overlay.style.left = '50%';
  overlay.style.transform = 'translateX(-50%)';
  overlay.style.fontSize = '16px';
  overlay.style.fontWeight = 'bold';
  overlay.style.color = '#fff';
  overlay.style.textShadow = '0 0 5px rgba(0, 0, 0, 0.8)';
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = '10';
  zapper.appendChild(overlay);
  zapper.overlay = overlay;

  const fontSize = Math.max(12, Math.min(24, size / 4));
  zapper.style.fontSize = `${fontSize}px`;
  zapper.style.color = '#fff';
  zapper.style.display = 'flex';
  zapper.style.alignItems = 'center';
  zapper.style.justifyContent = 'center';
  zapper.style.fontWeight = 'bold';
  zapper.style.textShadow = '0 0 5px rgba(0, 0, 0, 0.8)';

  // Add mouse event listeners for sending ships (check ownership when clicked)
  zapper.addEventListener('mousedown', (e) => {
    // Only allow dragging if zapper is owned by player at the time of click
    if (zapper.className.includes('player1')) {
      if (e.button === 0) {
        dragStartBubble = zapper;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
      } else if (e.button === 2) {
        dragStartBubble = zapper;
        isDraggingRightClick = true;
        isDraggingMiddleClick = false;
      } else if (e.button === 1) {
        dragStartBubble = zapper;
        isDraggingMiddleClick = true;
        isDraggingRightClick = false;
      }
    }
  });

  document.body.appendChild(zapper);
  zappers.push(zapper);
}

function createDebrisParticles(x, y, radius, previousOwner, colorOverride = null, sizeMultiplier = 1.0) {
  // Get color based on previous owner or use override
  let color;
  if (colorOverride) {
    color = colorOverride;
  } else if (previousOwner === 'player1') {
    color = { r: 0, g: 160, b: 0 }; // Green
  } else if (previousOwner === 'player2') {
    color = { r: 199, g: 21, b: 133 }; // Pink
  } else {
    color = { r: 70, g: 130, b: 180 }; // Blue (neutral)
  }
  
  // Scale particle count, size, and speed based on planet/turret size
  const sizeScale = (radius / 100) * sizeMultiplier; // Normalize to a typical planet size, apply multiplier
  const particleCount = Math.floor((15 + Math.floor(Math.random() * 11)) * Math.max(0.5, sizeScale));
  
  for (let i = 0; i < particleCount; i++) {
    const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.3;
    // Speed scales with size: larger planets have faster debris
    const baseSpeed = 100 + Math.random() * 150; // 100-250 px/s
    const speed = baseSpeed * sizeScale;
    
    debrisParticles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      color: color,
      size: (3 + Math.random() * 4) * sizeScale, // Size scales with planet size
      maxLifetime: 1.0, // 1 second
      lifetime: 1.0,
      createdTime: Date.now()
    });
  }
}

function createShipExplosionDebris(x, y, shipOwner) {
  // Get color based on ship owner
  let color;
  if (shipOwner === 'player1') {
    color = { r: 0, g: 160, b: 0 }; // Green
  } else if (shipOwner === 'pirate') {
    color = { r: 150, g: 100, b: 50 }; // Brown/pirate
  } else {
    color = { r: 199, g: 21, b: 133 }; // Pink
  }
  
  // Create 5-10 small, fast particles
  const particleCount = 5 + Math.floor(Math.random() * 6);
  
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 150 + Math.random() * 200; // 150-350 px/s (much faster than planet debris)
    
    debrisParticles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      color: color,
      size: 1 + Math.random() * 1.5, // 1-2.5px (much smaller)
      maxLifetime: 0.5, // 0.5 seconds (shorter lifetime)
      lifetime: 0.5,
      createdTime: Date.now()
    });
  }
}

function updateDebrisParticles(deltaTime) {
  debrisParticles = debrisParticles.filter(particle => {
    // Update position
    particle.x += particle.vx * deltaTime;
    particle.y += particle.vy * deltaTime;
    
    // Calculate remaining lifetime
    const age = (Date.now() - particle.createdTime) / 1000;
    particle.lifetime = particle.maxLifetime - age;
    
    // Remove if lifetime expired
    return particle.lifetime > 0;
  });
}

function drawDebrisParticles() {
  debrisParticles.forEach(particle => {
    // Normalize opacity based on remaining lifetime (0 to 1)
    const opacity = Math.max(0, Math.min(1, particle.lifetime / particle.maxLifetime));
    
    gameCtx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${opacity})`;
    gameCtx.beginPath();
    gameCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    gameCtx.fill();
    
    // Add slight glow
    gameCtx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${opacity * 0.3})`;
    gameCtx.beginPath();
    gameCtx.arc(particle.x, particle.y, particle.size * 1.5, 0, Math.PI * 2);
    gameCtx.fill();
  });
}

function spawnPirateRaid() {
  // Choose random target from all planets and turrets
  const allTargets = [...bubbles, ...laserTurrets];
  if (allTargets.length === 0) return;
  
  const target = allTargets[Math.floor(Math.random() * allTargets.length)];
  const targetShips = target.microBubbles;
  
  // Pirate ship count: 110-150% of target's ships
  const pirateShips = Math.max(1, Math.floor(targetShips * (1.1 + Math.random() * 0.4)));
  
  // Spawn from random edge of screen
  let startX, startY;
  const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
  
  if (edge === 0) { // Top
    startX = Math.random() * window.innerWidth;
    startY = -50;
  } else if (edge === 1) { // Right
    startX = window.innerWidth + 50;
    startY = Math.random() * window.innerHeight;
  } else if (edge === 2) { // Bottom
    startX = Math.random() * window.innerWidth;
    startY = window.innerHeight + 50;
  } else { // Left
    startX = -50;
    startY = Math.random() * window.innerHeight;
  }
  
  const targetX = parseInt(target.style.left) + parseInt(target.style.width) / 2;
  const targetY = parseInt(target.style.top) + parseInt(target.style.height) / 2;
  
  const dx = targetX - startX;
  const dy = targetY - startY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const duration = distance / SHIP_SPEED;
  
  pirateRaids.push({
    x: startX,
    y: startY,
    startX: startX,  // Store spawn position
    startY: startY,  // Store spawn position
    target: target,
    targetX: targetX,
    targetY: targetY,
    startTime: Date.now(),
    duration: duration * 1000,
    ships: pirateShips,
    actualProgress: 0,
    lastUpdateTime: Date.now()
  });
}

function updatePirateRaids() {
  pirateRaids = pirateRaids.filter(pirate => {
    const now = Date.now();
    const deltaTime = (now - pirate.lastUpdateTime) / 1000;
    pirate.lastUpdateTime = now;
    
    // Update progress
    const progressIncrement = (deltaTime * 1000 / pirate.duration);
    pirate.actualProgress += progressIncrement;
    
    // Update position based on total progress (like regular ships)
    pirate.x = pirate.startX + (pirate.targetX - pirate.startX) * pirate.actualProgress;
    pirate.y = pirate.startY + (pirate.targetY - pirate.startY) * pirate.actualProgress;
    
    // Check collision with target planet/turret (like regular ships do)
    const targetCenterX = parseInt(pirate.target.style.left) + parseInt(pirate.target.style.width) / 2;
    const targetCenterY = parseInt(pirate.target.style.top) + parseInt(pirate.target.style.height) / 2;
    const targetRadius = parseInt(pirate.target.style.width) / 2;
    const distanceToTarget = Math.sqrt((pirate.x - targetCenterX) ** 2 + (pirate.y - targetCenterY) ** 2);
    
    // Check if reached target (touching the edge)
    if (distanceToTarget <= targetRadius) {
      // Pirate raid arrives
      const previousOwner = pirate.target.className.includes('player1') ? 'player1' : 
                           pirate.target.className.includes('player2') ? 'player2' : 'neutral';
      const isNeutral = previousOwner === 'neutral';
      
      // Yellow pirate debris (half size) on all pirate arrivals
      const yellowColor = { r: 255, g: 215, b: 0 }; // Gold/yellow
      createDebrisParticles(targetCenterX, targetCenterY, targetRadius, null, yellowColor, 0.5);
      
      if (isNeutral) {
        // Target is neutral - pirates add to ship count
        pirate.target.microBubbles += pirate.ships;
        
        // Remove "empty" class if it was empty
        if (pirate.target.className.includes('empty')) {
          pirate.target.className = pirate.target.className.replace(' empty', '');
        }
      } else {
        // Target is owned - battle logic: pirates vs current garrison
        const remainingShips = pirate.ships - pirate.target.microBubbles;
        
        if (remainingShips > 0) {
          // Pirates win - target becomes neutral with remaining pirate ships
          pirate.target.microBubbles = remainingShips;
          const baseClass = pirate.target.isTurret ? 'turret' : 'bubble';
          pirate.target.className = `${baseClass} neutral`;
          
          // Create debris from previous owner
          createDebrisParticles(targetCenterX, targetCenterY, targetRadius, previousOwner);
          
          // Clear vassal relationships (planets only)
          if (!pirate.target.isTurret) {
            pirate.target.vassalTo = null;
            pirate.target.vassalMinimum = 1;
            bubbles.forEach(b => {
              if (b.vassalTo === pirate.target) {
                b.vassalTo = null;
                b.vassalMinimum = 1;
              }
            });
          }
          
          captureSound.play();
        } else {
          // Target wins - reduce garrison
          pirate.target.microBubbles -= pirate.ships;
          if (pirate.target.microBubbles === 0) {
            const baseClass = pirate.target.isTurret ? 'turret' : 'bubble';
            pirate.target.className = `${baseClass} neutral empty`;
          }
        }
      }
      
      pirate.target.countDisplay.textContent = pirate.target.microBubbles;
      checkVictory();
      return false; // Remove pirate
    }
    
    return true; // Keep pirate
  });
}

function drawPirateLines() {
  // Draw glowing lines for each pirate raid showing their path
  pirateRaids.forEach(pirate => {
    const color = '150, 100, 50'; // Brown/pirate color
    
    // Get target radius to calculate edge point
    const targetRadius = parseInt(pirate.target.style.width) / 2;
    
    // Calculate direction vector
    const dx = pirate.targetX - pirate.startX;
    const dy = pirate.targetY - pirate.startY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return;
    
    // Normalize direction vector
    const ndx = dx / distance;
    const ndy = dy / distance;
    
    // Start from spawn position (edge of screen)
    const startX = pirate.startX;
    const startY = pirate.startY;
    
    // End at target planet edge
    const endX = pirate.targetX - ndx * targetRadius;
    const endY = pirate.targetY - ndy * targetRadius;
    
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    
    // Outer glow
    gameCtx.strokeStyle = `rgba(${color}, 0.1)`;
    gameCtx.lineWidth = 8;
    gameCtx.stroke();
    
    // Inner line
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    gameCtx.strokeStyle = `rgba(${color}, 0.3)`;
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
}

function drawPirateRaids() {
  pirateRaids.forEach(pirate => {
    // Draw diamond shape
    const size = 12; // Larger than regular ships
    
    gameCtx.save();
    gameCtx.translate(pirate.x, pirate.y);
    gameCtx.rotate(Math.PI / 4); // Rotate 45 degrees for diamond look
    
    // Draw glowing diamond
    gameCtx.fillStyle = 'rgba(150, 100, 50, 0.8)'; // Brown/pirate color
    gameCtx.strokeStyle = 'rgba(255, 200, 100, 0.9)'; // Gold outline
    gameCtx.lineWidth = 2;
    
    gameCtx.beginPath();
    gameCtx.rect(-size/2, -size/2, size, size);
    gameCtx.fill();
    gameCtx.stroke();
    
    // Add glow
    gameCtx.shadowBlur = 8;
    gameCtx.shadowColor = 'rgba(255, 200, 100, 0.6)';
    gameCtx.beginPath();
    gameCtx.rect(-size/2, -size/2, size, size);
    gameCtx.stroke();
    
    gameCtx.restore();
    
    // Draw label above pirate ship
    const labelText = pirate.ships.toString();
    gameCtx.font = '20px Arial';
    gameCtx.fillStyle = 'rgb(255, 200, 100)';
    gameCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    gameCtx.lineWidth = 3;
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'bottom';
    
    gameCtx.strokeText(labelText, pirate.x, pirate.y - 15);
    gameCtx.fillText(labelText, pirate.x, pirate.y - 15);
  });
}

function createBubble(x, y, size, owner, microBubbles) {
  const bubble = document.createElement('div');
  bubble.style.left = `${x}px`;
  bubble.style.top = `${y}px`;
  bubble.style.width = `${size}px`;
  bubble.style.height = `${size}px`;
  
  // Calculate default ship count (50% less for neutral planets)
  if (microBubbles !== undefined) {
    bubble.microBubbles = microBubbles;
  } else if (owner === 'neutral') {
    bubble.microBubbles = Math.floor(Math.random() * 30); // 0-29 ships (50% of 10-59)
  } else {
    bubble.microBubbles = Math.floor(Math.random() * 50) + 10; // 10-59 ships
  }
  
  // Set class with "empty" suffix if neutral with 0 ships
  bubble.className = `bubble ${owner}` + (owner === 'neutral' && bubble.microBubbles === 0 ? ' empty' : '');
  
  bubble.growthRate = Math.floor(400000 / (size * 3));
  bubble.lastGrowth = Date.now();
  bubble.vassalTo = null; // Track if this planet is a vassal to another
  bubble.lastVassalSend = 0; // Track last time vassal sent a ship
  bubble.vassalMinimum = 1; // Minimum ships to keep before sending to master
  bubble.lastAttackTime = 0; // Track last time enemy AI attacked from this planet
  
  // Create wrapper for count displays to stack them vertically
  const countWrapper = document.createElement('div');
  countWrapper.style.display = 'flex';
  countWrapper.style.flexDirection = 'column';
  countWrapper.style.alignItems = 'center';
  countWrapper.style.position = 'relative';
  countWrapper.style.zIndex = '1';
  bubble.appendChild(countWrapper);
  
  // Create count display element
  const countDisplay = document.createElement('div');
  countDisplay.textContent = bubble.microBubbles;
  countWrapper.appendChild(countDisplay);
  bubble.countDisplay = countDisplay;
  
  // Create vassal minimum display element
  const vassalMinDisplay = document.createElement('div');
  vassalMinDisplay.style.fontSize = '0.7em';
  vassalMinDisplay.style.color = 'rgb(100, 200, 255)';
  vassalMinDisplay.style.textShadow = '0 0 3px rgba(0, 0, 0, 0.8)';
  vassalMinDisplay.style.marginTop = '2px';
  vassalMinDisplay.style.display = 'none';
  countWrapper.appendChild(vassalMinDisplay);
  bubble.vassalMinDisplay = vassalMinDisplay;
  
  // Create overlay element for showing required ships
  const overlay = document.createElement('div');
  overlay.className = 'bubble-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '-20px';
  overlay.style.left = '50%';
  overlay.style.transform = 'translateX(-50%)';
  overlay.style.fontSize = '16px';
  overlay.style.fontWeight = 'bold';
  overlay.style.color = 'rgba(0, 255, 100, 0.9)';
  overlay.style.textShadow = '0 0 3px rgba(0, 0, 0, 0.7), 1px 1px 2px rgba(0, 0, 0, 0.7)';
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = '10';
  bubble.appendChild(overlay);
  bubble.overlay = overlay;
  
  const fontSize = Math.max(12, Math.min(24, size / 4));
  bubble.style.fontSize = `${fontSize}px`;
  
  bubble.addEventListener('mousedown', (e) => {
    if (bubble.className.includes('player1')) {
      if (e.button === 0) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
      } else if (e.button === 2) {
        dragStartBubble = bubble;
        isDraggingRightClick = true;
        isDraggingMiddleClick = false;
      } else if (e.button === 1) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = true;
      }
    }
    e.preventDefault();
  });
  
  document.body.appendChild(bubble);
  bubbles.push(bubble);
}

function sendMicroBubbles(from, to, sendAll = false, sendOne = false, specificAmount = null, isPurpleShip = false) {
  let microBubblesToSend;
  if (specificAmount !== null) {
    microBubblesToSend = specificAmount;
  } else if (sendOne) {
    microBubblesToSend = from.microBubbles >= 1 ? 1 : 0;
  } else if (sendAll) {
    microBubblesToSend = Math.floor(from.microBubbles / 2);
  } else {
    microBubblesToSend = from.microBubbles;
  }
  
  // Ensure we don't send more than the planet currently has
  microBubblesToSend = Math.min(microBubblesToSend, from.microBubbles);
  
  if (microBubblesToSend === 0) return;
  
  sendSound.play();
  
  // Immediately decrement the full amount from the planet (unless it's a purple ship from a black hole)
  if (!isPurpleShip) {
    from.microBubbles -= microBubblesToSend;
    from.countDisplay.textContent = from.microBubbles;
  }
  
  const fromX = parseInt(from.style.left) + parseInt(from.style.width) / 2;
  const fromY = parseInt(from.style.top) + parseInt(from.style.height) / 2;
  const toX = parseInt(to.style.left) + parseInt(to.style.width) / 2;
  const toY = parseInt(to.style.top) + parseInt(to.style.height) / 2;
  const dx = toX - fromX;
  const dy = toY - fromY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const duration = distance / SHIP_SPEED;
  
  // Create unique squadron ID for this send command
  const squadronId = `squad_${Date.now()}_${Math.random()}`;
  
  // Store the owner at launch time so it doesn't change if planet is conquered
  const squadronOwner = isPurpleShip ? 'purple' : (from.className.includes('player1') ? 'player1' : 'player2');
  const squadronColor = isPurpleShip ? '#800080' : (squadronOwner === 'player1' ? '#00a000' : '#c71585');
  
  // Squadron-specific state (not shared with other squadrons from the same planet)
  let squadronRemainingToLaunch = microBubblesToSend;
  let lastLaunchTime = Date.now();
  const launchSessionId = gameSessionId; // Capture current session ID
  
  function releaseNextShip() {
    // Cancel this launch if game has been restarted
    if (launchSessionId !== gameSessionId) {
      activeSquadronLaunches.delete(squadronId);
      return;
    }
    
    if (squadronRemainingToLaunch > 0) {
      const currentTime = Date.now();
      if (currentTime - lastLaunchTime >= SHIP_RELEASE_DELAY) {
        squadronRemainingToLaunch -= 1;
        lastLaunchTime = currentTime;
        
        const microBubble = document.createElement('div');
        microBubble.className = 'microBubble';
        microBubble.style.left = `${fromX}px`;
        microBubble.style.top = `${fromY}px`;
        microBubble.style.backgroundColor = squadronColor;
        document.body.appendChild(microBubble);
        
        microBubbles.push({
          element: microBubble,
          target: to,
          startTime: currentTime,
          duration: duration * 1000,
          fromX: fromX,
          fromY: fromY,
          toX: toX,
          toY: toY,
          owner: squadronOwner,
          squadronId: squadronId,
          totalInSquadron: microBubblesToSend,
          remainingToLaunch: squadronRemainingToLaunch,
          actualProgress: 0,
          lastUpdateTime: currentTime,
          isPurpleShip: isPurpleShip
        });
      }
      requestAnimationFrame(releaseNextShip);
    } else {
      // All ships launched, remove from active launches
      activeSquadronLaunches.delete(squadronId);
    }
  }
  
  // Initialize tracking for this squadron
  if (!squadronDestroyedCount.has(squadronId)) {
    squadronDestroyedCount.set(squadronId, 0);
  }
  if (!squadronOriginalSizes.has(squadronId)) {
    squadronOriginalSizes.set(squadronId, microBubblesToSend);
  }
  
  // Track this squadron as actively launching
  activeSquadronLaunches.set(squadronId, squadronOwner);
  
  releaseNextShip();
}

function updateMicroBubbles() {
  microBubbles = microBubbles.filter(microBubble => {
    const now = Date.now();
    const deltaTime = (now - microBubble.lastUpdateTime) / 1000; // seconds
    microBubble.lastUpdateTime = now;
    
    // Calculate current position
    const currentX = microBubble.fromX + (microBubble.toX - microBubble.fromX) * microBubble.actualProgress;
    const currentY = microBubble.fromY + (microBubble.toY - microBubble.fromY) * microBubble.actualProgress;
    
    // Nebula slowdown disabled
    const speedMultiplier = 1.0;
    
    // Update actual progress
    const progressIncrement = (deltaTime * 1000 / microBubble.duration) * speedMultiplier;
    microBubble.actualProgress += progressIncrement;
    
    if (microBubble.actualProgress >= 1) {
      document.body.removeChild(microBubble.element);
      return false;
    }
    
    // Recalculate position with new progress
    const newX = microBubble.fromX + (microBubble.toX - microBubble.fromX) * microBubble.actualProgress;
    const newY = microBubble.fromY + (microBubble.toY - microBubble.fromY) * microBubble.actualProgress;
    
    microBubble.element.style.left = `${newX}px`;
    microBubble.element.style.top = `${newY}px`;
    
    const bubbleCenterX = parseInt(microBubble.target.style.left) + parseInt(microBubble.target.style.width) / 2;
    const bubbleCenterY = parseInt(microBubble.target.style.top) + parseInt(microBubble.target.style.height) / 2;
    const bubbleRadius = parseInt(microBubble.target.style.width) / 2;
    
    const distanceToBubble = Math.sqrt((newX - bubbleCenterX) ** 2 + (newY - bubbleCenterY) ** 2);
    
    if (distanceToBubble <= bubbleRadius) {
      document.body.removeChild(microBubble.element);
      
      // Increment destroyed count for this squadron (ship has arrived/completed)
      const destroyedCount = squadronDestroyedCount.get(microBubble.squadronId) || 0;
      squadronDestroyedCount.set(microBubble.squadronId, destroyedCount + 1);
      
      
      // Regular ships: existing logic
      if (microBubble.target.className.includes(microBubble.owner)) {
        // Friendly ship arriving
        const wasEmpty = microBubble.target.microBubbles === 0;
        microBubble.target.microBubbles += 1;
        // Remove "empty" class if it was empty
        if (wasEmpty) {
          microBubble.target.className = microBubble.target.className.replace(' empty', '');
        }
      } else {
         // Enemy ship arriving
         if (microBubble.target.microBubbles === 0) {
           // Target is at 0 (neutral), claim it
           // Store previous owner for debris effect
           const previousOwner = microBubble.target.className.includes('player1') ? 'player1' : 
                                  microBubble.target.className.includes('player2') ? 'player2' : 'neutral';
           
          microBubble.target.microBubbles = 1;
           const baseClass = microBubble.target.isTurret ? 'turret' : 'bubble';
           microBubble.target.className = `${baseClass} ${microBubble.owner}`; // No "empty" when claimed
           
           // Create debris particles at center of target
           const targetCenterX = parseInt(microBubble.target.style.left) + parseInt(microBubble.target.style.width) / 2;
           const targetCenterY = parseInt(microBubble.target.style.top) + parseInt(microBubble.target.style.height) / 2;
           const targetRadius = parseInt(microBubble.target.style.width) / 2;
           createDebrisParticles(targetCenterX, targetCenterY, targetRadius, previousOwner);
           
           // Clear vassal relationships when ownership changes (planets only)
           if (!microBubble.target.isTurret) {
             microBubble.target.vassalTo = null;
             microBubble.target.vassalMinimum = 1;
             // Also clear if this planet was anyone's master
             bubbles.forEach(b => {
               if (b.vassalTo === microBubble.target) {
                 b.vassalTo = null;
                 b.vassalMinimum = 1;
               }
             });
           }
           
          captureSound.play();
         } else {
           // Target has ships, reduce count
           microBubble.target.microBubbles -= 1;
           
           if (microBubble.target.microBubbles === 0) {
             // Just reached 0, make it neutral and empty
             // Store previous owner for debris effect
             const previousOwner = microBubble.target.className.includes('player1') ? 'player1' : 
                                    microBubble.target.className.includes('player2') ? 'player2' : 'neutral';
             
             const baseClass = microBubble.target.isTurret ? 'turret' : 'bubble';
             microBubble.target.className = `${baseClass} neutral empty`;
             
             // Create debris particles at center of target
             const targetCenterX = parseInt(microBubble.target.style.left) + parseInt(microBubble.target.style.width) / 2;
             const targetCenterY = parseInt(microBubble.target.style.top) + parseInt(microBubble.target.style.height) / 2;
             const targetRadius = parseInt(microBubble.target.style.width) / 2;
             createDebrisParticles(targetCenterX, targetCenterY, targetRadius, previousOwner);
             
             // Clear vassal relationships when becoming neutral (planets only)
             if (!microBubble.target.isTurret) {
               microBubble.target.vassalTo = null;
               microBubble.target.vassalMinimum = 1;
               // Also clear if this planet was anyone's master
               bubbles.forEach(b => {
                 if (b.vassalTo === microBubble.target) {
                   b.vassalTo = null;
                   b.vassalMinimum = 1;
                 }
               });
             }
             
             captureSound.play();
           }
         }
       }
      microBubble.target.countDisplay.textContent = microBubble.target.microBubbles;
      
      checkVictory();
      return false;
    }
    
    return true;
  });
}

function updateTurrets() {
  const now = Date.now();
  const LASER_COOLDOWN = 2000; // 2 seconds
  
  laserTurrets.forEach(turret => {
    const timeSinceLastFire = now - turret.lastLaserFire;
    if (timeSinceLastFire < LASER_COOLDOWN) return;
    
    const turretX = parseInt(turret.style.left) + parseInt(turret.style.width) / 2;
    const turretY = parseInt(turret.style.top) + parseInt(turret.style.height) / 2;
    
    const isNeutral = turret.className.includes('neutral');
    
    // Neutral turrets with ships shoot at nearest ship of either team (not pirates)
    if (isNeutral) {
      // Only fire if turret has ships
      if (turret.microBubbles === 0) return;
      
      // Find nearest ship from either team (player1 or player2)
      const allShips = microBubbles.filter(mb => mb.owner === 'player1' || mb.owner === 'player2');
      
      let nearestTarget = null;
      let nearestDistance = Infinity;
      
      allShips.forEach(ship => {
        const shipX = parseInt(ship.element.style.left);
        const shipY = parseInt(ship.element.style.top);
        const dx = shipX - turretX;
        const dy = shipY - turretY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Only consider ships within fire range
        if (distance < nearestDistance && distance <= turret.fireRange) {
          nearestDistance = distance;
          nearestTarget = ship;
        }
      });
      
      // Fire gray laser at nearest ship
      if (nearestTarget && nearestDistance <= turret.fireRange) {
        turret.lastLaserFire = now;
        
        const targetX = parseInt(nearestTarget.element.style.left);
        const targetY = parseInt(nearestTarget.element.style.top);
        
        // Add visual laser effect (gray)
        activeLasers.push({
          x1: turretX,
          y1: turretY,
          x2: targetX,
          y2: targetY,
          color: 'rgba(180, 180, 180, 0.9)', // Gray laser
          createdTime: now,
          duration: 200 // Laser visible for 200ms
        });
        
        // Create explosion debris at ship location
        createShipExplosionDebris(targetX, targetY, nearestTarget.owner);
        
        // Destroy the ship
        if (nearestTarget.element && nearestTarget.element.parentNode) {
          document.body.removeChild(nearestTarget.element);
        }
        
        // Increment destroyed count for this squadron
        const destroyedCount = squadronDestroyedCount.get(nearestTarget.squadronId) || 0;
        squadronDestroyedCount.set(nearestTarget.squadronId, destroyedCount + 1);
        
        const shipIndex = microBubbles.indexOf(nearestTarget);
        if (shipIndex > -1) {
          microBubbles.splice(shipIndex, 1);
        }
      }
      return; // Done processing neutral turret
    }
    
    // Owned turrets (player or enemy) - existing logic
    const turretOwner = turret.className.includes('player1') ? 'player1' : 'player2';
    const enemyOwner = turretOwner === 'player1' ? 'player2' : 'player1';
    
    // Find nearest enemy ship or pirate
    const enemyShips = microBubbles.filter(mb => mb.owner === enemyOwner);
    
    let nearestTarget = null;
    let nearestDistance = Infinity;
    let targetIsPirate = false;
    
    // Check enemy ships
    enemyShips.forEach(ship => {
      const shipX = parseInt(ship.element.style.left);
      const shipY = parseInt(ship.element.style.top);
      const dx = shipX - turretX;
      const dy = shipY - turretY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Only consider ships within fire range
      if (distance < nearestDistance && distance <= turret.fireRange) {
        nearestDistance = distance;
        nearestTarget = ship;
        targetIsPirate = false;
      }
    });
    
    // Also check pirate raids (neutral threat to all)
    pirateRaids.forEach(pirate => {
      const dx = pirate.x - turretX;
      const dy = pirate.y - turretY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Only consider pirates within fire range
      if (distance < nearestDistance && distance <= turret.fireRange) {
        nearestDistance = distance;
        nearestTarget = pirate;
        targetIsPirate = true;
      }
    });
    
    // Only fire if nearest target is within range
    if (nearestTarget && nearestDistance <= turret.fireRange) {
      // Fire laser and destroy target
      turret.lastLaserFire = now;
      
      if (targetIsPirate) {
        // Target is a pirate raid
        const targetX = nearestTarget.x;
        const targetY = nearestTarget.y;
        
        // Add visual laser effect
        activeLasers.push({
          x1: turretX,
          y1: turretY,
          x2: targetX,
          y2: targetY,
          color: turretOwner === 'player1' ? 'rgba(0, 255, 100, 0.9)' : 'rgba(255, 105, 180, 0.9)',
          createdTime: now,
          duration: 200 // Laser visible for 200ms
        });
        
        // Create explosion debris
        createShipExplosionDebris(targetX, targetY, 'pirate');
        
        // Reduce pirate ship count
        nearestTarget.ships -= 1;
        if (nearestTarget.ships <= 0) {
          // Remove pirate if all ships destroyed
          const pirateIndex = pirateRaids.indexOf(nearestTarget);
          if (pirateIndex > -1) {
            pirateRaids.splice(pirateIndex, 1);
          }
        }
      } else {
        // Target is a regular ship
        const targetX = parseInt(nearestTarget.element.style.left);
        const targetY = parseInt(nearestTarget.element.style.top);
        
        // Add visual laser effect
        activeLasers.push({
          x1: turretX,
          y1: turretY,
          x2: targetX,
          y2: targetY,
          color: turretOwner === 'player1' ? 'rgba(0, 255, 100, 0.9)' : 'rgba(255, 105, 180, 0.9)',
          createdTime: now,
          duration: 200 // Laser visible for 200ms
        });
        
        // Create explosion debris at ship location
        createShipExplosionDebris(targetX, targetY, nearestTarget.owner);
        
        // Destroy the ship
        if (nearestTarget.element && nearestTarget.element.parentNode) {
          document.body.removeChild(nearestTarget.element);
        }
        
        // Increment destroyed count for this squadron
        const destroyedCount = squadronDestroyedCount.get(nearestTarget.squadronId) || 0;
        squadronDestroyedCount.set(nearestTarget.squadronId, destroyedCount + 1);
        
        const shipIndex = microBubbles.indexOf(nearestTarget);
        if (shipIndex > -1) {
          microBubbles.splice(shipIndex, 1);
        }
      }
    }
  });
}

function updateZappers() {
  const now = Date.now();
  const ZAPPER_FIRE_COOLDOWN = 1000; // 1 second

  zappers.forEach(zapper => {
    const timeSinceLastFire = now - zapper.lastZapperFire;
    if (timeSinceLastFire < ZAPPER_FIRE_COOLDOWN) return;

    // Determine targets based on ownership
    const isNeutral = zapper.className.includes('neutral');
    const isPlayer = zapper.className.includes('player1');
    const isEnemy = zapper.className.includes('player2');

    let targets = [];

    if (isNeutral) {
      // Neutral zappers fire at ALL planets only
      targets = [...bubbles];
    } else if (isPlayer || isEnemy) {
      // Owned zappers only fire at enemy planets
      const enemyOwner = isPlayer ? 'player2' : 'player1';
      targets = [
        ...bubbles.filter(b => b.className.includes(enemyOwner) || b.className.includes('neutral'))
      ];
    }

    // Filter targets to only those within fire range
    const zapperX = parseInt(zapper.style.left) + parseInt(zapper.style.width) / 2;
    const zapperY = parseInt(zapper.style.top) + parseInt(zapper.style.height) / 2;

    const targetsInRange = targets.filter(target => {
      const targetX = parseInt(target.style.left) + parseInt(target.style.width) / 2;
      const targetY = parseInt(target.style.top) + parseInt(target.style.height) / 2;
      const distance = Math.sqrt((targetX - zapperX) ** 2 + (targetY - zapperY) ** 2);
      return distance <= zapper.fireRange;
    });

    // Fire laser at each target in range (color based on zapper owner)
    if (targetsInRange.length > 0) {
      zapper.lastZapperFire = now;
      targetsInRange.forEach(target => {
        const targetX = parseInt(target.style.left) + parseInt(target.style.width) / 2;
        const targetY = parseInt(target.style.top) + parseInt(target.style.height) / 2;

        // Determine laser color based on zapper owner
        let laserColor;
        if (zapper.className.includes('player1')) {
          laserColor = 'rgba(0, 255, 0, 0.9)'; // Green laser for player1
        } else if (zapper.className.includes('player2')) {
          laserColor = 'rgba(255, 105, 180, 0.9)'; // Pink laser for player2
        } else {
          laserColor = 'rgba(180, 180, 180, 0.9)'; // Gray laser for neutral
        }

        // Add visual laser effect
        activeLasers.push({
          x1: zapperX,
          y1: zapperY,
          x2: targetX,
          y2: targetY,
          color: laserColor,
          createdTime: now,
          duration: 200 // Laser visible for 200ms
        });

        // If target is a ship, destroy it
        if (target.element && target.element.parentNode && target.element.className.includes('microBubble')) {
          // Create explosion debris at ship location
          createShipExplosionDebris(targetX, targetY, target.owner);

          // Destroy the ship
          if (target.element && target.element.parentNode) {
            document.body.removeChild(target.element);
          }

          // Increment destroyed count for this squadron
          const destroyedCount = squadronDestroyedCount.get(target.squadronId) || 0;
          squadronDestroyedCount.set(target.squadronId, destroyedCount + 1);

          const shipIndex = microBubbles.indexOf(target);
          if (shipIndex > -1) {
            microBubbles.splice(shipIndex, 1);
          }
        }
        // If target is a planet, subtract 1 ship (but not below 0)
        else if (target.className && target.className.includes('bubble') && !target.element) {
          // Subtract 1 ship from planet, but not below 0
          if (target.microBubbles > 0) {
            target.microBubbles -= 1;
            target.countDisplay.textContent = target.microBubbles;

            // Update planet class if it reaches 0
            if (target.microBubbles === 0) {
              target.className = 'bubble neutral empty';

              // Clear vassal relationships when planet becomes neutral
              target.vassalTo = null;
              target.vassalMinimum = 1;
              // Also clear if this planet was anyone's master
              bubbles.forEach(b => {
                if (b.vassalTo === target) {
                  b.vassalTo = null;
                  b.vassalMinimum = 1;
                }
              });
            }
          }
        }
      });
    }
  });
}

function updateBubbles() {
  const now = Date.now();
  bubbles.forEach(bubble => {
    if (!bubble.className.includes('neutral')) {
      if (now - bubble.lastGrowth >= bubble.growthRate) {
        bubble.microBubbles += 1;
        bubble.countDisplay.textContent = bubble.microBubbles;
        bubble.lastGrowth = now;
      }
    }
    
    // Update vassal minimum display
    if (bubble.vassalTo && bubbles.includes(bubble.vassalTo)) {
      bubble.vassalMinDisplay.style.display = 'block';
      bubble.vassalMinDisplay.textContent = `(${bubble.vassalMinimum})`;
    } else {
      bubble.vassalMinDisplay.style.display = 'none';
    }
    
    // Handle vassal behavior
    if (bubble.vassalTo && bubble.microBubbles > bubble.vassalMinimum) {
      // Check if vassal is still valid (both planets exist, both owned by player, and master is still player1)
      if (bubbles.includes(bubble.vassalTo) && 
          bubble.className.includes('player1') && 
          bubble.vassalTo.className.includes('player1')) {
        // Send one ship at a time, keeping vassalMinimum at home
        const timeSinceLastSend = now - bubble.lastVassalSend;
        if (timeSinceLastSend >= SHIP_RELEASE_DELAY) {
          sendMicroBubbles(bubble, bubble.vassalTo, false, false, 1);
          bubble.lastVassalSend = now;
        }
      } else {
        // Clear invalid vassal relationship
        bubble.vassalTo = null;
        bubble.vassalMinimum = 1;
      }
    }
  });

  // Enemy AI logic (skip if in passive enemies mode)
  if (!passiveEnemiesMode) {
  const enemyPlanets = bubbles.filter(b => b.className.includes('player2'));
    const enemyTurrets = laserTurrets.filter(t => t.className.includes('player2'));
    const allEnemyStructures = [...enemyPlanets, ...enemyTurrets];
    
  const otherPlanets = bubbles.filter(b => !b.className.includes('player2'));
    const otherTurrets = laserTurrets.filter(t => !t.className.includes('player2'));
    const allOtherStructures = [...otherPlanets, ...otherTurrets];
    
    const ENEMY_ATTACK_COOLDOWN = 5000; // 5 seconds between attacks per planet

    allEnemyStructures.forEach(enemyStructure => {
      const timeSinceLastAttack = now - (enemyStructure.lastAttackTime || 0);
      if (timeSinceLastAttack >= ENEMY_ATTACK_COOLDOWN && enemyStructure.microBubbles > 1) {
        const target = allOtherStructures.find(p => p.microBubbles < enemyStructure.microBubbles);
      if (target) {
          // Never send all ships - keep at least 1 at home, send at most 50%
          const microBubblesToSend = Math.min(enemyStructure.microBubbles - 1, Math.floor(enemyStructure.microBubbles / 2));
          sendMicroBubbles(enemyStructure, target, false, false, microBubblesToSend);
          enemyStructure.lastAttackTime = now;
      }
    }
  });
  }
}

function createPlankton() {
  for (let i = 0; i < 50; i++) {
    plankton.push({
      x: Math.random() * gameCanvas.width,
      y: Math.random() * gameCanvas.height,
      size: Math.random() * 2 + 1,
      speedX: (Math.random() - 0.5) * 0.5,
      speedY: (Math.random() - 0.5) * 0.5,
      angle: Math.random() * Math.PI * 2
    });
  }
}

function createNebulae() {
  nebulae = [];
  const nebulaCount = 13 + Math.floor(Math.random() * 3); // 13-15 nebulae
  
  for (let i = 0; i < nebulaCount; i++) {
    // Create more vibrant, distinct colors
    const colorType = Math.floor(Math.random() * 5);
    let color;
    switch(colorType) {
      case 0: // Bright purple
        color = { r: 180, g: 80, b: 255 };
        break;
      case 1: // Cyan
        color = { r: 80, g: 200, b: 255 };
        break;
      case 2: // Magenta
        color = { r: 255, g: 80, b: 200 };
        break;
      case 3: // Blue-purple
        color = { r: 120, g: 100, b: 255 };
        break;
      case 4: // Green-cyan
        color = { r: 80, g: 255, b: 180 };
        break;
    }
    
    nebulae.push({
      x: Math.random() * gameCanvas.width,
      y: Math.random() * gameCanvas.height,
      radius: 150 + Math.random() * 350, // 150-500px radius (much bigger!)
      driftX: (Math.random() - 0.5) * 10, // -5 to 5 pixels per second
      driftY: (Math.random() - 0.5) * 10,
      color: color,
      pulsePhase: Math.random() * Math.PI * 2
    });
  }
}

function updateNebulae(deltaTime) {
  nebulae.forEach(nebula => {
    // Drift the nebula
    nebula.x += nebula.driftX * deltaTime;
    nebula.y += nebula.driftY * deltaTime;
    
    // Wrap around screen edges
    if (nebula.x < -nebula.radius) nebula.x = gameCanvas.width + nebula.radius;
    if (nebula.x > gameCanvas.width + nebula.radius) nebula.x = -nebula.radius;
    if (nebula.y < -nebula.radius) nebula.y = gameCanvas.height + nebula.radius;
    if (nebula.y > gameCanvas.height + nebula.radius) nebula.y = -nebula.radius;
    
    // Update pulse phase
    nebula.pulsePhase += deltaTime * 0.5;
  });
}

function getNebulaSlowdown(x, y) {
  let maxSlowdown = 0; // 0 = no slowdown, 1 = maximum slowdown
  
  nebulae.forEach(nebula => {
    const dx = x - nebula.x;
    const dy = y - nebula.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < nebula.radius) {
      // Calculate slowdown based on distance from center
      // At center (distance = 0): slowdown = 1.0 (50% speed)
      // At edge (distance = radius): slowdown = 0.0 (100% speed)
      const slowdown = 1.0 - (distance / nebula.radius);
      maxSlowdown = Math.max(maxSlowdown, slowdown);
    }
  });
  
  return maxSlowdown;
}

function createShootingStar() {
  // Use the map's consistent direction
  let x, y, vx, vy;
  
  if (shootingStarDirection === 0) { // from top
    x = Math.random() * gameCanvas.width;
    y = -50;
    vx = (Math.random() - 0.5) * 400; // -200 to 200 px/s horizontal
    vy = 300 + Math.random() * 400; // 300-700 px/s downward
  } else if (shootingStarDirection === 1) { // from right
    x = gameCanvas.width + 50;
    y = Math.random() * gameCanvas.height;
    vx = -(300 + Math.random() * 400); // -300 to -700 px/s leftward
    vy = (Math.random() - 0.5) * 400;
  } else if (shootingStarDirection === 2) { // from bottom
    x = Math.random() * gameCanvas.width;
    y = gameCanvas.height + 50;
    vx = (Math.random() - 0.5) * 400;
    vy = -(300 + Math.random() * 400); // -300 to -700 px/s upward
  } else { // from left
    x = -50;
    y = Math.random() * gameCanvas.height;
    vx = 300 + Math.random() * 400; // 300-700 px/s rightward
    vy = (Math.random() - 0.5) * 400;
  }
  
  shootingStars.push({
    x: x,
    y: y,
    vx: vx,
    vy: vy,
    brightness: 0.7 + Math.random() * 0.3, // 0.7-1.0
    trailLength: 40 + Math.random() * 60, // 40-100px trail
    createdTime: Date.now()
  });
}

function updateShootingStars(deltaTime) {
  shootingStars = shootingStars.filter(star => {
    // Update position
    star.x += star.vx * deltaTime;
    star.y += star.vy * deltaTime;
    
    // Remove if off screen (with margin)
    if (star.x < -200 || star.x > gameCanvas.width + 200 ||
        star.y < -200 || star.y > gameCanvas.height + 200) {
      return false;
    }
    
    return true;
  });
}

function drawLasers() {
  const now = Date.now();
  
  // Remove expired lasers and draw active ones
  activeLasers = activeLasers.filter(laser => {
    const age = now - laser.createdTime;
    if (age > laser.duration) return false;
    
    // Draw laser beam
    const opacity = 1.0 - (age / laser.duration); // Fade out
    
    gameCtx.strokeStyle = laser.color.replace('0.9', opacity.toString());
    gameCtx.lineWidth = 3;
    gameCtx.lineCap = 'round';
    gameCtx.shadowBlur = 10;
    gameCtx.shadowColor = laser.color;
    gameCtx.beginPath();
    gameCtx.moveTo(laser.x1, laser.y1);
    gameCtx.lineTo(laser.x2, laser.y2);
    gameCtx.stroke();
    gameCtx.shadowBlur = 0;
    
    return true;
  });
}

function drawShootingStars() {
  shootingStars.forEach(star => {
    // Calculate trail direction (opposite of velocity)
    const speed = Math.sqrt(star.vx * star.vx + star.vy * star.vy);
    const tailX = star.x - (star.vx / speed) * star.trailLength;
    const tailY = star.y - (star.vy / speed) * star.trailLength;
    
    // Draw gradient line for trail
    const gradient = gameCtx.createLinearGradient(tailX, tailY, star.x, star.y);
    gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.3 * star.brightness})`);
    gradient.addColorStop(1, `rgba(255, 255, 255, ${star.brightness})`);
    
    gameCtx.strokeStyle = gradient;
    gameCtx.lineWidth = 2;
    gameCtx.lineCap = 'round';
    gameCtx.beginPath();
    gameCtx.moveTo(tailX, tailY);
    gameCtx.lineTo(star.x, star.y);
    gameCtx.stroke();
    
    // Draw bright head
    gameCtx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
    gameCtx.beginPath();
    gameCtx.arc(star.x, star.y, 2, 0, Math.PI * 2);
    gameCtx.fill();
    
    // Optional glow
    gameCtx.fillStyle = `rgba(200, 220, 255, ${0.3 * star.brightness})`;
    gameCtx.beginPath();
    gameCtx.arc(star.x, star.y, 4, 0, Math.PI * 2);
    gameCtx.fill();
  });
}

function drawTurretRanges() {
  laserTurrets.forEach(turret => {
    const turretX = parseInt(turret.style.left) + parseInt(turret.style.width) / 2;
    const turretY = parseInt(turret.style.top) + parseInt(turret.style.height) / 2;
    
    // Draw yellow range circle
    gameCtx.beginPath();
    gameCtx.arc(turretX, turretY, turret.fireRange, 0, Math.PI * 2);
    gameCtx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
  
  // Draw range circles for zappers (color based on owner)
  zappers.forEach(zapper => {
    const zapperX = parseInt(zapper.style.left) + parseInt(zapper.style.width) / 2;
    const zapperY = parseInt(zapper.style.top) + parseInt(zapper.style.height) / 2;

    // Draw range circle with color based on owner
    let rangeColor;
    if (zapper.className.includes('player1')) {
      rangeColor = 'rgba(0, 255, 0, 0.4)'; // Green range for player1
    } else if (zapper.className.includes('player2')) {
      rangeColor = 'rgba(255, 105, 180, 0.4)'; // Pink range for player2
    } else {
      rangeColor = 'rgba(128, 128, 128, 0.4)'; // Gray range for neutral
    }

    gameCtx.beginPath();
    gameCtx.arc(zapperX, zapperY, zapper.fireRange, 0, Math.PI * 2);
    gameCtx.strokeStyle = rangeColor;
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
}

function drawVassalLines() {
  const time = Date.now() / 1000; // Time in seconds for animation
  
  bubbles.forEach(bubble => {
    if (bubble.vassalTo && bubbles.includes(bubble.vassalTo)) {
      const vassalX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
      const vassalY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
      const masterX = parseInt(bubble.vassalTo.style.left) + parseInt(bubble.vassalTo.style.width) / 2;
      const masterY = parseInt(bubble.vassalTo.style.top) + parseInt(bubble.vassalTo.style.height) / 2;
      
      // Calculate distance and direction
      const dx = masterX - vassalX;
      const dy = masterY - vassalY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance === 0) return;
      
      // Draw animated sine wave
      gameCtx.beginPath();
      gameCtx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
      gameCtx.lineWidth = 2;
      
      const segments = 50;
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const x = vassalX + dx * t;
        const y = vassalY + dy * t;
        
        // Calculate perpendicular offset for sine wave
        const perpX = -dy / distance;
        const perpY = dx / distance;
        
        // Animate the sine wave by subtracting time offset (flows from vassal to master)
        const waveOffset = Math.sin(t * Math.PI * 4 - time * 3) * 10;
        const finalX = x + perpX * waveOffset;
        const finalY = y + perpY * waveOffset;
        
        if (i === 0) {
          gameCtx.moveTo(finalX, finalY);
        } else {
          gameCtx.lineTo(finalX, finalY);
        }
      }
      
      gameCtx.stroke();
    }
  });
}

function drawNebulae() {
  nebulae.forEach(nebula => {
    const pulse = Math.sin(nebula.pulsePhase) * 0.15 + 0.85; // 0.7 to 1.0
    
    // Create radial gradient for nebula (much more visible)
    const gradient = gameCtx.createRadialGradient(
      nebula.x, nebula.y, 0,
      nebula.x, nebula.y, nebula.radius
    );
    
    const opacity = 0.4 * pulse; // Increased from 0.15 to 0.4
    gradient.addColorStop(0, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${opacity})`);
    gradient.addColorStop(0.4, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${opacity * 0.6})`);
    gradient.addColorStop(0.7, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${opacity * 0.3})`);
    gradient.addColorStop(1, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0)`);
    
    gameCtx.fillStyle = gradient;
    gameCtx.beginPath();
    gameCtx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
    gameCtx.fill();
    
    // Add some wispy details (more visible)
    gameCtx.globalAlpha = 0.25 * pulse; // Increased from 0.1
    for (let i = 0; i < 3; i++) {
      const angle = nebula.pulsePhase * 0.3 + i * Math.PI * 2 / 3;
      const offsetX = Math.cos(angle) * nebula.radius * 0.3;
      const offsetY = Math.sin(angle) * nebula.radius * 0.3;
      
      const detailGradient = gameCtx.createRadialGradient(
        nebula.x + offsetX, nebula.y + offsetY, 0,
        nebula.x + offsetX, nebula.y + offsetY, nebula.radius * 0.6
      );
      
      detailGradient.addColorStop(0, `rgba(${Math.min(255, nebula.color.r + 60)}, ${Math.min(255, nebula.color.g + 60)}, ${Math.min(255, nebula.color.b + 60)}, 0.5)`);
      detailGradient.addColorStop(0.5, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0.2)`);
      detailGradient.addColorStop(1, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0)`);
      
      gameCtx.fillStyle = detailGradient;
      gameCtx.beginPath();
      gameCtx.arc(nebula.x + offsetX, nebula.y + offsetY, nebula.radius * 0.6, 0, Math.PI * 2);
      gameCtx.fill();
    }
    gameCtx.globalAlpha = 1;
  });
}

function drawPlankton() {
  gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  
  // Draw nebulae first (background layer)
  drawNebulae();
  
  gameCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  plankton.forEach(p => {
    gameCtx.beginPath();
    gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    gameCtx.fill();
    
    p.angle += (Math.random() - 0.5) * 0.1;
    p.x += Math.cos(p.angle) * p.speedX;
    p.y += Math.sin(p.angle) * p.speedY;
    
    if (p.x < 0) p.x = gameCanvas.width;
    if (p.x > gameCanvas.width) p.x = 0;
    if (p.y < 0) p.y = gameCanvas.height;
    if (p.y > gameCanvas.height) p.y = 0;
  });
  
  // Draw rippling corona on capturable planets/turrets during left click drag (only for smart send targets)
  if (dragStartBubble && !isDraggingRightClick && !isDraggingMiddleClick) {
    const time = Date.now();

    // Check planets
    bubbles.forEach(bubble => {
      if (bubble === dragStartBubble) return;

      // Only show corona for enemy/neutral planets (not own planets)
      if (bubble.className.includes('player1')) {
        // For own planets, show corona if we're sending 50%
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const shipsToSend = Math.floor(dragStartBubble.microBubbles / 2);
        if (shipsToSend > 0 && maxWeCanSend >= shipsToSend) {
          const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
          const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
          const bubbleRadius = parseInt(bubble.style.width) / 2;

          // Create rippling corona effect
          for (let i = 0; i < 3; i++) {
            const phase = (time / 1000 + i * 0.4) % 1;
            const rippleRadius = bubbleRadius + 10 + phase * 20;
            const opacity = (1 - phase) * 0.3;

            gameCtx.beginPath();
            gameCtx.arc(bubbleX, bubbleY, rippleRadius, 0, Math.PI * 2);
            gameCtx.strokeStyle = `rgba(0, 255, 100, ${opacity})`;
            gameCtx.lineWidth = 3;
            gameCtx.stroke();
          }
        }
        return;
      }

      // Calculate if we have enough for smart send
      const targetShips = bubble.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      const isNeutral = bubble.className.includes('neutral');

      let bonusAmount;
      if (isNeutral) {
        bonusAmount = 1;
      } else if (bubble.className.includes('player2')) {
        const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
        const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
        const targetBubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const targetBubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
        const travelTimeMs = (distance / SHIP_SPEED) * 1000;
        let estimatedShips = targetShips + Math.ceil(travelTimeMs / bubble.growthRate);
        const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
        const totalTimeMs = travelTimeMs + launchDelayMs;
        const shipsGenerated = Math.ceil(totalTimeMs / bubble.growthRate);
        bonusAmount = Math.max(1, shipsGenerated) + 1; // At least 1, +1 extra for enemy planets to account for last-second growth
      }

      const idealSend = targetShips + bonusAmount;

      // Only highlight if we have enough for smart send
      if (maxWeCanSend >= idealSend) {
        const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const bubbleRadius = parseInt(bubble.style.width) / 2;

        // Create rippling corona effect
        for (let i = 0; i < 3; i++) {
          const phase = (time / 1000 + i * 0.4) % 1;
          const rippleRadius = bubbleRadius + 10 + phase * 20;
          const opacity = (1 - phase) * 0.3;

          gameCtx.beginPath();
          gameCtx.arc(bubbleX, bubbleY, rippleRadius, 0, Math.PI * 2);
          gameCtx.strokeStyle = `rgba(0, 255, 100, ${opacity})`;
          gameCtx.lineWidth = 3;
          gameCtx.stroke();
        }
      }
    });
    
    // Check turrets
    laserTurrets.forEach(turret => {
      if (turret === dragStartBubble) return;
      
      // Skip player's own turrets
      if (turret.className.includes('player1')) return;
      
      // Calculate if we have enough to capture this turret
      const targetShips = turret.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      
      // Turrets don't grow, always +1 bonus
      const bonusAmount = 1;
      const idealSend = targetShips + bonusAmount;
      
      // Only highlight if we have enough
      if (maxWeCanSend >= idealSend) {
        const turretX = parseInt(turret.style.left) + parseInt(turret.style.width) / 2;
        const turretY = parseInt(turret.style.top) + parseInt(turret.style.height) / 2;
        const turretRadius = parseInt(turret.style.width) / 2;
        
        // Create rippling corona effect (square for turrets)
        for (let i = 0; i < 3; i++) {
          const phase = (time / 1000 + i * 0.4) % 1;
          const rippleSize = turretRadius + 10 + phase * 20;
          const opacity = (1 - phase) * 0.3;
          
          gameCtx.strokeStyle = `rgba(0, 255, 100, ${opacity})`;
          gameCtx.lineWidth = 3;
          gameCtx.strokeRect(turretX - rippleSize, turretY - rippleSize, rippleSize * 2, rippleSize * 2);
        }
      }
    });
    
    // Check zappers
    zappers.forEach(zapper => {
      if (zapper === dragStartBubble) return;

      // Skip player's own zappers
      if (zapper.className.includes('player1')) return;

      // Calculate if we have enough to capture this zapper
      const targetShips = zapper.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;

      // Zappers don't grow, always +1 bonus
      const bonusAmount = 1;
      const idealSend = targetShips + bonusAmount;
      
      // Only highlight if we have enough
      if (maxWeCanSend >= idealSend) {
        const zapperX = parseInt(zapper.style.left) + parseInt(zapper.style.width) / 2;
        const zapperY = parseInt(zapper.style.top) + parseInt(zapper.style.height) / 2;
        const zapperRadius = parseInt(zapper.style.width) / 2;

        // Create rippling corona effect (circular for zappers, green tint for capturable)
        for (let i = 0; i < 3; i++) {
          const phase = (time / 1000 + i * 0.4) % 1;
          const rippleRadius = zapperRadius + 10 + phase * 20;
          const opacity = (1 - phase) * 0.3;

          gameCtx.beginPath();
          gameCtx.arc(zapperX, zapperY, rippleRadius, 0, Math.PI * 2);
          gameCtx.strokeStyle = `rgba(0, 255, 100, ${opacity})`;
          gameCtx.lineWidth = 3;
          gameCtx.stroke();
        }
      }
    });
  }
}

// Track last known positions of squadron labels and their HTML elements
const squadronLabelPositions = new Map();
const squadronLabelElements = new Map();

function drawSquadronCounts() {
  // Group microBubbles by squadron
  const squadrons = new Map();
  
  microBubbles.forEach(mb => {
    if (!squadrons.has(mb.squadronId)) {
      squadrons.set(mb.squadronId, []);
    }
    squadrons.get(mb.squadronId).push(mb);
  });
  
  squadrons.forEach((ships, squadronId) => {
    if (ships.length === 0) return;
    
    // Use the tracked original squadron size and subtract destroyed ships
    const originalSize = squadronOriginalSizes.get(squadronId) || ships[0].totalInSquadron;
    const destroyedShips = squadronDestroyedCount.get(squadronId) || 0;
    const totalCount = originalSize - destroyedShips;
    
    // Skip singleton squadrons (1 ship total) - don't show label, but clean up if it exists
    if (totalCount <= 1) {
      const element = squadronLabelElements.get(squadronId);
      if (element && element.parentNode) {
        document.body.removeChild(element);
      }
      squadronLabelElements.delete(squadronId);
      squadronLabelPositions.delete(squadronId);
      return;
    }
    
    // Find the leading bubble (furthest along in progress)
    let leadingShip = ships[0];
    let maxProgress = 0;
    
    ships.forEach(ship => {
      const progress = (Date.now() - ship.startTime) / ship.duration;
      if (progress > maxProgress) {
        maxProgress = progress;
        leadingShip = ship;
      }
    });
    
    // Calculate stopping point based on destination planet's edge
    const targetPlanet = leadingShip.target;
    const targetRadius = parseInt(targetPlanet.style.width) / 2;
    const totalDistance = Math.sqrt((leadingShip.toX - leadingShip.fromX) ** 2 + (leadingShip.toY - leadingShip.fromY) ** 2);
    // Buffer: planet radius + text height (20px) + offset above ship (10px) + margin (10px)
    const textBuffer = targetRadius + 40;
    const stopDistance = totalDistance - textBuffer;
    const maxProgressBeforePlanet = Math.max(0, stopDistance / totalDistance);
    
    // Calculate position of leading ship, capped to stop before destination planet
    const progress = Math.min((Date.now() - leadingShip.startTime) / leadingShip.duration, maxProgressBeforePlanet);
    const leadX = leadingShip.fromX + (leadingShip.toX - leadingShip.fromX) * progress;
    const leadY = leadingShip.fromY + (leadingShip.toY - leadingShip.fromY) * progress;
    
    // Get or initialize stored position
    if (!squadronLabelPositions.has(squadronId)) {
      squadronLabelPositions.set(squadronId, { x: leadX, y: leadY });
    }
    
    const storedPos = squadronLabelPositions.get(squadronId);
    
    // Only update position if we're moving forward (don't jump back)
    const dx = leadX - leadingShip.fromX;
    const dy = leadY - leadingShip.fromY;
    const currentDist = Math.sqrt(dx * dx + dy * dy);
    
    const storedDx = storedPos.x - leadingShip.fromX;
    const storedDy = storedPos.y - leadingShip.fromY;
    const storedDist = Math.sqrt(storedDx * storedDx + storedDy * storedDy);
    
    if (currentDist > storedDist) {
      storedPos.x = leadX;
      storedPos.y = leadY;
    }
    
    // Create or update HTML element for this squadron
    let labelElement = squadronLabelElements.get(squadronId);
    if (!labelElement) {
      labelElement = document.createElement('div');
      labelElement.style.position = 'absolute';
      labelElement.style.fontFamily = 'Arial';
      labelElement.style.fontSize = '20px';
      labelElement.style.fontWeight = 'bold';
      labelElement.style.textShadow = '0 0 4px rgba(0, 0, 0, 0.8), 1px 1px 3px rgba(0, 0, 0, 0.8)';
      labelElement.style.pointerEvents = 'none';
      labelElement.style.zIndex = '1000';
      labelElement.style.transform = 'translate(-50%, -100%)';
      document.body.appendChild(labelElement);
      squadronLabelElements.set(squadronId, labelElement);
    }
    
    // Update element position, content and color
    const color = leadingShip.owner === 'player1' ? 'rgb(0, 255, 100)' : 'rgb(255, 105, 180)';
    labelElement.style.color = color;
    labelElement.style.left = `${storedPos.x}px`;
    labelElement.style.top = `${storedPos.y - 10}px`;
    labelElement.textContent = totalCount.toString();
  });
  
  // Clean up positions and elements for squadrons that no longer exist
  const activeSquadronIds = new Set(squadrons.keys());
  for (const squadronId of squadronLabelPositions.keys()) {
    if (!activeSquadronIds.has(squadronId)) {
      squadronLabelPositions.delete(squadronId);
      const element = squadronLabelElements.get(squadronId);
      if (element && element.parentNode) {
        document.body.removeChild(element);
      }
      squadronLabelElements.delete(squadronId);
      squadronDestroyedCount.delete(squadronId); // Clean up destroyed count tracking
      squadronOriginalSizes.delete(squadronId); // Clean up original size tracking
    }
  }
}

function drawSquadronLines() {
  // Draw glowing lines for each squadron in transit
  // Group microBubbles by unique routes to draw one line per squadron
  const routes = new Map();
  
  microBubbles.forEach(mb => {
    const key = `${mb.fromX},${mb.fromY}-${mb.toX},${mb.toY}-${mb.owner}`;
    if (!routes.has(key)) {
      routes.set(key, { fromX: mb.fromX, fromY: mb.fromY, toX: mb.toX, toY: mb.toY, owner: mb.owner });
    }
  });
  
  routes.forEach(route => {
    const color = route.owner === 'player1' ? '0, 160, 0' : '199, 21, 133'; // Green for player1, pink for player2
    
    // Combine bubbles and turrets to search for source and target structures
    const allStructures = [...bubbles, ...laserTurrets];
    
    // Find the source structure (planet or turret) to get its radius
    const sourceStructure = allStructures.find(s => {
      const centerX = parseInt(s.style.left) + parseInt(s.style.width) / 2;
      const centerY = parseInt(s.style.top) + parseInt(s.style.height) / 2;
      return Math.abs(centerX - route.fromX) < 1 && Math.abs(centerY - route.fromY) < 1;
    });
    
    // Find the target structure (planet or turret) to get its radius
    const targetStructure = allStructures.find(s => {
      const centerX = parseInt(s.style.left) + parseInt(s.style.width) / 2;
      const centerY = parseInt(s.style.top) + parseInt(s.style.height) / 2;
      return Math.abs(centerX - route.toX) < 1 && Math.abs(centerY - route.toY) < 1;
    });
    
    if (!sourceStructure || !targetStructure) return;
    
    const sourceRadius = parseInt(sourceStructure.style.width) / 2;
    const targetRadius = parseInt(targetStructure.style.width) / 2;
    
    // Calculate direction vector
    const dx = route.toX - route.fromX;
    const dy = route.toY - route.fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return;
    
    // Normalize direction vector
    const ndx = dx / distance;
    const ndy = dy / distance;
    
    // Calculate edge points
    const startX = route.fromX + ndx * sourceRadius;
    const startY = route.fromY + ndy * sourceRadius;
    const endX = route.toX - ndx * targetRadius;
    const endY = route.toY - ndy * targetRadius;
    
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    
    // Outer glow
    gameCtx.strokeStyle = `rgba(${color}, 0.1)`;
    gameCtx.lineWidth = 8;
    gameCtx.stroke();
    
    // Inner line
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    gameCtx.strokeStyle = `rgba(${color}, 0.3)`;
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
}

function drawArrow() {
  uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
  
  // Apply hover scaling to enemy planets while dragging
  if (dragStartBubble && dragEndPos) {
    bubbles.forEach(bubble => {
      if (!bubble.className.includes('player1')) {
        const rect = bubble.getBoundingClientRect();
        const isHovering = dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
                          dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
        
        if (isHovering) {
          bubble.style.transform = 'scale(1.02)';
          bubble.style.opacity = '1';
        } else {
          bubble.style.transform = '';
          bubble.style.opacity = '0.8';
        }
      }
    });
  } else {
    // Reset all enemy planet transforms when not dragging
    bubbles.forEach(bubble => {
      if (!bubble.className.includes('player1')) {
        bubble.style.transform = '';
        bubble.style.opacity = '0.8';
      }
    });
  }
  
  // Update bubble and turret overlays during left click drag
  if (dragStartBubble && !isDraggingRightClick && !isDraggingMiddleClick) {
    // Update bubble overlays
    bubbles.forEach(bubble => {
      if (bubble === dragStartBubble) {
        bubble.overlay.style.display = 'none';
        return;
      }
      
      // Calculate if we have enough to capture this planet
      const targetShips = bubble.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      const isNeutral = bubble.className.includes('neutral');
      
      let bonusAmount;
      if (isNeutral) {
        bonusAmount = 1;
      } else if (bubble.className.includes('player2')) {
        const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
        const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
        const targetBubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const targetBubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
        const travelTimeMs = (distance / SHIP_SPEED) * 1000;
        let estimatedShips = targetShips + Math.ceil(travelTimeMs / bubble.growthRate);
        const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
        const totalTimeMs = travelTimeMs + launchDelayMs;
        const shipsGenerated = Math.ceil(totalTimeMs / bubble.growthRate);
        bonusAmount = Math.max(1, shipsGenerated) + 1; // At least 1, +1 extra for enemy planets to account for last-second growth
      } else {
        // For own planets, show "50%" overlay if we're sending 50%
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const shipsToSend = Math.floor(dragStartBubble.microBubbles / 2);
        if (shipsToSend > 0 && maxWeCanSend >= shipsToSend) {
          bubble.overlay.textContent = '50%';
          bubble.overlay.style.display = 'block';
        } else {
          bubble.overlay.style.display = 'none';
        }
        return; // Skip player's own planets for smart send calculation
      }
      
      const idealSend = targetShips + bonusAmount;
      
      // Only show count if we have enough
      if (maxWeCanSend >= idealSend) {
        bubble.overlay.textContent = idealSend.toString();
        bubble.overlay.style.display = 'block';
      } else {
        bubble.overlay.style.display = 'none';
      }
    });
    
    // Update turret overlays
    laserTurrets.forEach(turret => {
      if (turret === dragStartBubble) {
        turret.overlay.style.display = 'none';
        return;
      }
      
      // Calculate if we have enough to capture this turret
      const targetShips = turret.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      const isNeutral = turret.className.includes('neutral');
      
      let bonusAmount;
      if (isNeutral || turret.isTurret) {
        bonusAmount = 1; // Turrets don't grow, always +1
      } else if (turret.className.includes('player2')) {
        bonusAmount = 1; // Enemy turrets don't grow either
      } else {
        turret.overlay.style.display = 'none';
        return; // Skip player's own turrets
      }
      
      const idealSend = targetShips + bonusAmount;
      
      // Only show count if we have enough
      if (maxWeCanSend >= idealSend) {
        turret.overlay.textContent = idealSend.toString();
        turret.overlay.style.display = 'block';
      } else {
        turret.overlay.style.display = 'none';
      }
    });
    
    // Update zapper overlays
    zappers.forEach(zapper => {
      if (zapper === dragStartBubble) {
        zapper.overlay.style.display = 'none';
        return;
      }

      // Calculate if we have enough to capture this zapper
      const targetShips = zapper.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;

      let bonusAmount;
      if (zapper.isZapper) {
        bonusAmount = 1; // Zappers don't grow, always +1
      } else if (zapper.className.includes('player2')) {
        bonusAmount = 1; // Enemy zappers don't grow either
      } else {
        zapper.overlay.style.display = 'none';
        return; // Skip player's own zappers
      }

      const idealSend = targetShips + bonusAmount;

      // Only show count if we have enough
      if (maxWeCanSend >= idealSend) {
        zapper.overlay.textContent = idealSend.toString();
        zapper.overlay.style.display = 'block';
      } else {
        zapper.overlay.style.display = 'none';
      }
    });
  } else {
    // Hide all overlays when not dragging
    bubbles.forEach(bubble => {
      bubble.overlay.style.display = 'none';
    });
    laserTurrets.forEach(turret => {
      turret.overlay.style.display = 'none';
    });
    zappers.forEach(zapper => {
      zapper.overlay.style.display = 'none';
    });
  }
  
  if (dragStartBubble && dragEndPos) {
    // Check if the dragStartBubble is still owned by the player
    if (!dragStartBubble.className.includes('player1')) {
      dragStartBubble = null;
      dragEndPos = null;
      isDraggingRightClick = false;
      isDraggingMiddleClick = false;
      return;
    }

    const startX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
    const startY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
    const endX = dragEndPos.x;
    const endY = dragEndPos.y;
    
    // Find bubble, turret, or black hole under mouse cursor
    hoveredBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
             dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
    });
    
    // If no bubble found, check turrets
    if (!hoveredBubble) {
      hoveredBubble = laserTurrets.find(turret => {
        const rect = turret.getBoundingClientRect();
        return dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
               dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
      });
    }
    
    // If no turret found, check zappers
    if (!hoveredBubble) {
      hoveredBubble = zappers.find(zapper => {
        const rect = zapper.getBoundingClientRect();
        return dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
               dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
      });
    }
    
    // Determine arrow color based on drag type and conditions
    let arrowColor;
    let microBubblesToSend;
    let showNumbers = true;
    let displayFormula = '';
    
    if (isDraggingMiddleClick) {
      // Middle click: Check if target is allied
      if (hoveredBubble && hoveredBubble !== dragStartBubble && hoveredBubble.className.includes('player1')) {
        // Middle click to allied base: Blue - establishing vassal relationship (no numbers shown)
        arrowColor = 'rgba(0, 100, 255, 0.7)';
        showNumbers = false;
      } else {
        // Middle click to non-allied base: send 50%
        arrowColor = 'rgba(0, 100, 255, 0.7)';
        microBubblesToSend = Math.floor(dragStartBubble.microBubbles / 2);
        displayFormula = '50%';
      }
    } else if (isDraggingRightClick) {
      // Right click (100% - 1): Yellow
      arrowColor = 'rgba(255, 255, 0, 0.7)';
      microBubblesToSend = Math.max(0, dragStartBubble.microBubbles - 1);
      displayFormula = '100% - 1';
    } else {
      // Left click: smart send - always keep 1 at home
      if (hoveredBubble && hoveredBubble !== dragStartBubble) {
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isOwnPlanet = hoveredBubble.className.includes('player1');
        
        if (isOwnPlanet) {
          // Sending to own planet: send 50%
          microBubblesToSend = Math.floor(dragStartBubble.microBubbles / 2);
          displayFormula = '50%';
          arrowColor = 'rgba(0, 255, 0, 0.7)';
        } else {
          const targetShips = hoveredBubble.microBubbles;
          const isNeutral = hoveredBubble.className.includes('neutral');
          const isTurret = hoveredBubble.isTurret;
          const isZapper = hoveredBubble.isZapper;
          
          // Calculate bonus based on travel time and growth rate
          let bonusAmount;
          if (isNeutral || isTurret || isZapper) {
            bonusAmount = 1; // Neutrals, turrets, and black holes don't grow
          } else {
            // Calculate distance and travel time
            const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
            const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
            const targetBubbleX = parseInt(hoveredBubble.style.left) + parseInt(hoveredBubble.style.width) / 2;
            const targetBubbleY = parseInt(hoveredBubble.style.top) + parseInt(hoveredBubble.style.height) / 2;
            const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
            const travelTimeMs = (distance / SHIP_SPEED) * 1000;
            
            // Estimate ships to send (iterative approach)
            let estimatedShips = targetShips + Math.ceil(travelTimeMs / hoveredBubble.growthRate);
            // Account for launch delay: last ship arrives at travelTime + SHIP_RELEASE_DELAY * (estimatedShips - 1)
            const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
            const totalTimeMs = travelTimeMs + launchDelayMs;
            
            // Calculate how many ships the target will generate during total time
            const shipsGenerated = Math.ceil(totalTimeMs / hoveredBubble.growthRate);
            bonusAmount = Math.max(1, shipsGenerated) + 1; // At least 1, +1 extra for enemy planets to account for last-second growth
          }
          
          const idealSend = targetShips + bonusAmount;
          
          if (maxWeCanSend >= idealSend) {
            // We have enough to capture - show smart send
            microBubblesToSend = idealSend;
            const bonus = microBubblesToSend - targetShips;
            displayFormula = `${targetShips} + ${bonus}`;
            arrowColor = 'rgba(0, 255, 0, 0.7)'; // Green - can capture
          } else {
            // We don't have enough to capture - show "not enough ships"
            microBubblesToSend = 0;
            displayFormula = 'not enough ships';
            arrowColor = 'rgba(255, 0, 0, 0.7)'; // Red - can't capture
          }
        }
      } else {
        showNumbers = false;
        arrowColor = 'rgba(255, 255, 255, 0.5)';
      }
    }
    
    uiCtx.beginPath();
    uiCtx.moveTo(startX, startY);
    uiCtx.lineTo(endX, endY);
    uiCtx.strokeStyle = arrowColor;
    uiCtx.lineWidth = 2;
    uiCtx.stroke();
    
    const angle = Math.atan2(endY - startY, endX - startX);
    uiCtx.beginPath();
    uiCtx.moveTo(endX, endY);
    uiCtx.lineTo(endX- 15 * Math.cos(angle - Math.PI / 6), endY - 15 * Math.sin(angle - Math.PI / 6));
    uiCtx.lineTo(endX - 15 * Math.cos(angle + Math.PI / 6), endY - 15 * Math.sin(angle + Math.PI / 6));
    uiCtx.closePath();
    uiCtx.fillStyle = arrowColor;
    uiCtx.fill();

    if (showNumbers) {
    uiCtx.font = '16px Arial';
    uiCtx.fillStyle = 'white';
    uiCtx.textAlign = 'center';
    uiCtx.textBaseline = 'middle';
      
      // Show formula above the number
      if (displayFormula) {
        uiCtx.fillText(displayFormula, (startX + endX) / 2, (startY + endY) / 2 - 20);
      }
      
      uiCtx.fillText(microBubblesToSend.toString(), (startX + endX) / 2, (startY + endY) / 2);
      
      // For left click smart send with enough ships, show percentage below
      if (!isDraggingMiddleClick && !isDraggingRightClick && hoveredBubble && hoveredBubble !== dragStartBubble) {
        const targetShips = hoveredBubble.microBubbles;
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isNeutral = hoveredBubble.className.includes('neutral');
        const isTurret = hoveredBubble.isTurret;
        const isZapper = hoveredBubble.isZapper;
        
        // Calculate bonus based on travel time and growth rate
        let bonusAmount;
        if (isNeutral || isTurret || isZapper) {
          bonusAmount = 1; // Neutrals, turrets, and black holes don't grow
        } else {
          const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
          const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
          const targetBubbleX = parseInt(hoveredBubble.style.left) + parseInt(hoveredBubble.style.width) / 2;
          const targetBubbleY = parseInt(hoveredBubble.style.top) + parseInt(hoveredBubble.style.height) / 2;
          const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
          const travelTimeMs = (distance / SHIP_SPEED) * 1000;
          
          // Estimate ships to send (iterative approach)
          let estimatedShips = targetShips + Math.ceil(travelTimeMs / hoveredBubble.growthRate);
          // Account for launch delay
          const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
          const totalTimeMs = travelTimeMs + launchDelayMs;
          
          const shipsGenerated = Math.ceil(totalTimeMs / hoveredBubble.growthRate);
          bonusAmount = Math.max(1, shipsGenerated) + 1; // At least 1, +1 extra for enemy planets to account for last-second growth
        }
        
        // Only show percentage if we have enough to send the bonus
        if (maxWeCanSend >= targetShips + bonusAmount) {
          const percentage = Math.round((microBubblesToSend / dragStartBubble.microBubbles) * 100);
          uiCtx.fillText(`(${percentage}%)`, (startX + endX) / 2, (startY + endY) / 2 + 20);
        }
      }
    }
  }
}

function gameLoop() {
  const now = Date.now();
  const deltaTime = (now - lastFrameTime) / 1000; // seconds
  lastFrameTime = now;
  
  if (!gameStarted) {
    drawStartScreen();
  } else {
    // Randomly spawn shooting stars (less common)
    const timeSinceLastStar = now - lastShootingStarTime;
    const minInterval = 8000; // Minimum 8 seconds between stars
    const maxInterval = 20000; // Maximum 20 seconds between stars
    const nextStarInterval = minInterval + Math.random() * (maxInterval - minInterval);
    
    if (timeSinceLastStar >= nextStarInterval) {
      createShootingStar();
      lastShootingStarTime = now;
    }
    
    // Spawn pirate raids at random intervals (5s to 30s)
    const timeSinceLastPirate = now - lastPirateSpawn;
    if (timeSinceLastPirate >= nextPirateInterval) {
      spawnPirateRaid();
      lastPirateSpawn = now;
      nextPirateInterval = 5000 + Math.random() * 25000; // 5s to 30s
    }
    
    // Update game state first
    updateNebulae(deltaTime);
    updateShootingStars(deltaTime);
    updateDebrisParticles(deltaTime); // Update debris particles
    updatePirateRaids(); // Update pirate raids
    updateTurrets(); // Update turret firing (before drawing so squadron counts are accurate)
    updateZappers(); // Update zapper firing
    updateMicroBubbles();
    updateBubbles();
    checkVictory();
    
    // Then draw everything
    drawBackground();
    drawPlankton();
    drawShootingStars(); // Draw shooting stars on top of background
    drawTurretRanges(); // Draw turret range circles
    drawLasers(); // Draw laser beams
    drawVassalLines();
    drawSquadronLines();
    drawPirateLines(); // Draw pirate raid lines
    drawDebrisParticles(); // Draw debris particles from ownership changes
    drawPirateRaids(); // Draw pirate raids
    drawSquadronCounts();
    drawArrow();
  }
  requestAnimationFrame(gameLoop);
}

function drawBackground() {
  const gradient = backgroundCtx.createRadialGradient(
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, 0,
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, Math.max(backgroundCanvas.width, backgroundCanvas.height) / 2
  );
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
}

function drawStartScreen() {
  const gradient = backgroundCtx.createLinearGradient(0, 0, 0, backgroundCanvas.height);
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

  updateStartScreenBubbles();
  drawStartScreenBubbles();
}

function createStartScreenBubbles() {
  for (let i = 0; i < 200; i++) {
    startScreenBubbles.push({
      x: Math.random() * backgroundCanvas.width,
      y: backgroundCanvas.height + Math.random() * backgroundCanvas.height,
      size: Math.random() * 60 + 10,
      speed: Math.random() * 1.5 + 0.5,
      color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 0.5 + 0.3})`,
      wobbleSpeed: Math.random() * 0.02 + 0.01,
      wobbleAmount: Math.random() * 2 + 1
    });
  }
}

function updateStartScreenBubbles() {
  startScreenBubbles.forEach(bubble => {
    bubble.y -= bubble.speed;
    bubble.x += Math.sin(Date.now() * bubble.wobbleSpeed) * bubble.wobbleAmount;
    if (bubble.y + bubble.size < 0) {
      bubble.y = backgroundCanvas.height + bubble.size;
      bubble.x = Math.random() * backgroundCanvas.width;
    }
  });
}

function drawStartScreenBubbles() {
  backgroundCtx.save();
  backgroundCtx.globalCompositeOperation = 'lighter';
  startScreenBubbles.forEach(bubble => {
    backgroundCtx.beginPath();
    backgroundCtx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
    const gradient = backgroundCtx.createRadialGradient(
      bubble.x, bubble.y, 0,
      bubble.x, bubble.y, bubble.size
    );
    gradient.addColorStop(0, bubble.color);
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    backgroundCtx.fillStyle = gradient;
    backgroundCtx.fill();
  });
  backgroundCtx.restore();
}

function isOverlapping(x, y, size) {
  const minDistance = 40;
  
  // Check against bubbles
  for (const bubble of bubbles) {
    const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
    const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
    const bubbleSize = parseInt(bubble.style.width);
    const distance = Math.sqrt((x - bubbleX) ** 2 + (y - bubbleY) ** 2);
    if (distance < (size + bubbleSize) / 2 + minDistance) {
      return true;
    }
  }
  
  // Check against turrets
  for (const turret of laserTurrets) {
    const turretX = parseInt(turret.style.left) + parseInt(turret.style.width) / 2;
    const turretY = parseInt(turret.style.top) + parseInt(turret.style.height) / 2;
    const turretSize = parseInt(turret.style.width);
    const distance = Math.sqrt((x - turretX) ** 2 + (y - turretY) ** 2);
    if (distance < (size + turretSize) / 2 + minDistance) {
      return true;
    }
  }
  
  // Check against zappers
  for (const zapper of zappers) {
    const zapperX = parseInt(zapper.style.left) + parseInt(zapper.style.width) / 2;
    const zapperY = parseInt(zapper.style.top) + parseInt(zapper.style.height) / 2;
    const zapperSize = parseInt(zapper.style.width);
    const distance = Math.sqrt((x - zapperX) ** 2 + (y - zapperY) ** 2);
    if (distance < (size + zapperSize) / 2 + minDistance) {
      return true;
    }
  }
  
  return false;
}

function initializeGame(restartSameMap = false, passiveEnemies = false) {
  // Increment session ID to cancel all ongoing ship launches
  gameSessionId++;
  
  // Remove all bubbles
  bubbles.forEach(bubble => {
    if (bubble.parentNode) {
      document.body.removeChild(bubble);
    }
  });
  bubbles = [];
  
  // Remove all ships (microBubbles) that have been sent from any planet
  microBubbles.forEach(mb => {
    if (mb.element && mb.element.parentNode) {
      document.body.removeChild(mb.element);
    }
  });
  microBubbles = [];
  
  // Also remove any leftover microBubble elements that might not be tracked
  document.querySelectorAll('.microBubble').forEach(el => {
    if (el.parentNode) {
      document.body.removeChild(el);
    }
  });
  
  // Remove all squadron label HTML elements
  squadronLabelElements.forEach((element) => {
    if (element && element.parentNode) {
      document.body.removeChild(element);
    }
  });
  squadronLabelElements.clear();
  squadronLabelPositions.clear();
  
  plankton = [];
  shootingStars = [];
  activeLasers = [];
  debrisParticles = [];
  pirateRaids = [];
  squadronDestroyedCount.clear();
  squadronOriginalSizes.clear();
  activeSquadronLaunches.clear();
  
  // Reset pirate spawn timing
  lastPirateSpawn = Date.now();
  nextPirateInterval = 5000 + Math.random() * 25000; // 5s to 30s
  
  // Remove all turrets
  laserTurrets.forEach(turret => {
    if (turret.parentNode) {
      document.body.removeChild(turret);
    }
  });
  laserTurrets = [];
  
  // Remove all zappers
  zappers.forEach(zapper => {
    if (zapper.parentNode) {
      document.body.removeChild(zapper);
    }
  });
  zappers = [];
  
  // Set random shooting star direction for this map
  shootingStarDirection = Math.floor(Math.random() * 4); // 0-3
  
  // Clear all commands of ships to be sent
  dragStartBubble = null;
  dragEndPos = null;
  isDraggingRightClick = false;
  isDraggingMiddleClick = false;
  
  // Set passive enemies mode
  passiveEnemiesMode = passiveEnemies;
  
  const maxSize = 99 * 4;
  const minSize = 40;
  const padding = 10;

  let attempts = 0;
  const maxAttempts = 1000;

  // Random planet count: 5-10 planets
  const totalPlanets = passiveEnemies ? 10 : Math.floor(Math.random() * 6) + 5; // 5-10 planets
  const enemyCount = passiveEnemies ? 9 : Math.min(Math.floor(Math.random() * 3) + 1, totalPlanets - 2); // 1-3 enemies, but leave room for player and at least 1 neutral
  const neutralCount = totalPlanets - enemyCount - 1;

  if (restartSameMap && gameState.length > 0) {
    gameState.forEach(bubble => {
      createBubble(bubble.x, bubble.y, bubble.size, bubble.owner, bubble.microBubbles);
    });
  } else {
    for (let i = 0; i < totalPlanets; i++) {
      let x, y, size;
      attempts = 0;
      do {
        size = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
        x = Math.floor(Math.random() * (window.innerWidth - size - 2 * padding)) + padding;
        y = Math.floor(Math.random() * (window.innerHeight - size - 2 * padding)) + padding;
        attempts++;
        if (attempts > maxAttempts) {
          console.log("Could not place all bubbles without overlap");
          break;
        }
      } while (isOverlapping(x + size / 2, y + size / 2, size));
    
      if (attempts <= maxAttempts) {
        let owner;
        if (i === 0) {
          owner = 'player1';
        } else if (passiveEnemies) {
          owner = 'player2'; // All other planets are enemies in passive mode
        } else if (i < 1 + enemyCount) {
          owner = 'player2';
        } else {
          owner = 'neutral';
        }
        createBubble(x, y, size, owner);
      }
    }

    gameState = bubbles.map(bubble => ({
      x: parseInt(bubble.style.left),
      y: parseInt(bubble.style.top),
      size: parseInt(bubble.style.width),
      owner: bubble.className.split(' ')[1],
      microBubbles: bubble.microBubbles
    }));
    
    // Apply zero-ship logic to neutral planets
    const neutralBubbles = bubbles.filter(b => b.className.includes('neutral'));
    if (neutralBubbles.length > 0 && !passiveEnemies) {
      const randomValue = Math.random();
      if (randomValue < 0.25) {
        // 25% chance: ALL neutrals start with 0 ships
        neutralBubbles.forEach(neutral => {
          neutral.microBubbles = 0;
          neutral.className = neutral.className.includes('empty') ? neutral.className : neutral.className + ' empty';
          neutral.countDisplay.textContent = '0';
        });
      } else if (randomValue < 0.5) {
        // 25% chance: At least 1 neutral starts with 0 ships
        const randomNeutral = neutralBubbles[Math.floor(Math.random() * neutralBubbles.length)];
        randomNeutral.microBubbles = 0;
        randomNeutral.className = randomNeutral.className.includes('empty') ? randomNeutral.className : randomNeutral.className + ' empty';
        randomNeutral.countDisplay.textContent = '0';
      }
      // 50% chance: normal random ship counts (do nothing)
    }
    
    // Update gameState after zero-ship modifications
    gameState = bubbles.map(bubble => ({
      x: parseInt(bubble.style.left),
      y: parseInt(bubble.style.top),
      size: parseInt(bubble.style.width),
      owner: bubble.className.split(' ')[1],
      microBubbles: bubble.microBubbles
    }));
  }

  // Ensure player doesn't start with less than more than one enemy
  const playerBubble = bubbles.find(b => b.className.includes('player1'));
  const enemyBubbles = bubbles.filter(b => b.className.includes('player2'));
  
  if (playerBubble && enemyBubbles.length > 0) {
    // Sort enemies by ship count descending
    const sortedEnemies = enemyBubbles.sort((a, b) => b.microBubbles - a.microBubbles);
    
    // Count how many enemies have more ships than player
    const strongerEnemies = sortedEnemies.filter(e => e.microBubbles > playerBubble.microBubbles);
    
    // If more than one enemy is stronger, boost player to match the second strongest
    if (strongerEnemies.length > 1) {
      playerBubble.microBubbles = strongerEnemies[1].microBubbles;
      playerBubble.countDisplay.textContent = playerBubble.microBubbles;
    }
  }

  createPlankton();
  createNebulae();
  
  // Create or restore laser turrets
  if (restartSameMap && turretState.length > 0) {
    // Restore turrets from saved state
    turretState.forEach(turretData => {
      createTurret(turretData.x, turretData.y, turretData.size, turretData.fireRange, turretData.microBubbles, turretData.owner);
    });
  } else {
    // Create 0-2 laser turrets
    const turretCount = Math.floor(Math.random() * 3); // 0, 1, or 2
    for (let i = 0; i < turretCount; i++) {
      let x, y, size;
      attempts = 0;
      do {
        size = 60; // Fixed size for turrets
        x = Math.floor(Math.random() * (window.innerWidth - size - 2 * padding)) + padding;
        y = Math.floor(Math.random() * (window.innerHeight - size - 2 * padding)) + padding;
        attempts++;
        if (attempts > maxAttempts) {
          console.log("Could not place all turrets without overlap");
          break;
        }
      } while (isOverlapping(x, y, size));
      
      if (attempts <= maxAttempts) {
        // Determine turret owner: 25% player1, 25% player2, 50% neutral
        const ownerRoll = Math.random();
        let turretOwner;
        if (ownerRoll < 0.25) {
          turretOwner = 'player1';
        } else if (ownerRoll < 0.5) {
          turretOwner = 'player2';
        } else {
          turretOwner = 'neutral';
        }
        
        createTurret(x, y, size, null, null, turretOwner);
      }
    }
    
    // Save turret state
    turretState = laserTurrets.map(turret => ({
      x: parseInt(turret.style.left),
      y: parseInt(turret.style.top),
      size: parseInt(turret.style.width),
      fireRange: turret.fireRange,
      microBubbles: turret.microBubbles,
      owner: turret.className.includes('player1') ? 'player1' : 
             turret.className.includes('player2') ? 'player2' : 'neutral'
    }));
  }
  
  // Create or restore zapper
  if (restartSameMap && zapperState) {
    // Restore zapper from saved state
    createZapper(zapperState.x, zapperState.y, zapperState.size, zapperState.microBubbles, zapperState.owner, zapperState.fireRange);
  } else {
    // Create zapper on 25% of maps
    if (Math.random() < 0.25) {
      let x, y, size;
      attempts = 0;
      do {
        size = 80; // Zappers are slightly larger
        x = Math.floor(Math.random() * (window.innerWidth - size - 2 * padding)) + padding;
        y = Math.floor(Math.random() * (window.innerHeight - size - 2 * padding)) + padding;
        attempts++;
        if (attempts > maxAttempts) {
          console.log("Could not place zapper without overlap");
          break;
        }
      } while (isOverlapping(x, y, size));

      if (attempts <= maxAttempts) {
        const randomShips = Math.floor(Math.random() * 30); // 0-29 ships, like neutral planets/turrets
        createZapper(x, y, size, randomShips, 'neutral');
      }
    }

    // Save zapper state
    if (zappers.length > 0) {
      const zapper = zappers[0];
      zapperState = {
        x: parseInt(zapper.style.left),
        y: parseInt(zapper.style.top),
        size: parseInt(zapper.style.width),
        microBubbles: zapper.microBubbles,
        owner: zapper.className.includes('player1') ? 'player1' :
               zapper.className.includes('player2') ? 'player2' : 'neutral',
        fireRange: zapper.fireRange
      };
    } else {
      zapperState = null;
    }
  }
}

function checkVictory() {
  const player1Bubbles = bubbles.filter(bubble => bubble.className.includes('player1'));
  const player2Bubbles = bubbles.filter(bubble => bubble.className.includes('player2'));
  const player1Turrets = laserTurrets.filter(turret => turret.className.includes('player1'));
  const player2Turrets = laserTurrets.filter(turret => turret.className.includes('player2'));
  const player1Zappers = zappers.filter(z => z.className.includes('player1'));
  const player2Zappers = zappers.filter(z => z.className.includes('player2'));
  const player1MicroBubbles = microBubbles.filter(mb => mb.owner === 'player1');
  const player2MicroBubbles = microBubbles.filter(mb => mb.owner === 'player2');
  
  // Check if any squadrons are actively launching (ships queued but not yet released)
  const player1ShipsLaunching = Array.from(activeSquadronLaunches.values()).includes('player1');
  const player2ShipsLaunching = Array.from(activeSquadronLaunches.values()).includes('player2');
  
  // Player 2 loses only if they have no planets, no turrets, no zappers, no ships in transit, AND no ships launching
  if (player2Bubbles.length === 0 && player2Turrets.length === 0 && player2Zappers.length === 0 && player2MicroBubbles.length === 0 && !player2ShipsLaunching) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Victory!';
  } else if (player1Bubbles.length === 0 && player1Turrets.length === 0 && player1Zappers.length === 0 && player1MicroBubbles.length === 0 && !player1ShipsLaunching) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Defeat!';
  }
}

document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  if (dragStartBubble) {
    dragEndPos = { x: e.clientX, y: e.clientY };
  }
});

document.addEventListener('mouseup', (e) => {
  if ((e.button === 0 || e.button === 1 || e.button === 2) && dragStartBubble) {
    // Check bubbles, turrets, and black holes
    let endBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return e.clientX >= rect.left && e.clientX <= rect.right &&
             e.clientY >= rect.top && e.clientY <= rect.bottom;
    });
    
    // If no bubble found, check turrets
    if (!endBubble) {
      endBubble = laserTurrets.find(turret => {
        const rect = turret.getBoundingClientRect();
        return e.clientX >= rect.left && e.clientX <= rect.right &&
               e.clientY >= rect.top && e.clientY <= rect.bottom;
      });
    }
    
    // If no turret found, check zappers
    if (!endBubble) {
      endBubble = zappers.find(zapper => {
        const rect = zapper.getBoundingClientRect();
        return e.clientX >= rect.left && e.clientX <= rect.right &&
               e.clientY >= rect.top && e.clientY <= rect.bottom;
      });
    }

    if (endBubble && endBubble !== dragStartBubble) {
      // Calculate the amount to send based on drag type
      let amountToSend = 0; // Default to not sending

      if (isDraggingMiddleClick) {
        // Middle click: check if target is allied
        const isAllied = endBubble.className.includes('player1');
        
        if (isAllied) {
          // Middle click to allied base: establish vassal relationship
          // Determine which is smaller
          const startSize = parseInt(dragStartBubble.style.width);
          const endSize = parseInt(endBubble.style.width);
          
          if (startSize < endSize) {
            // Start planet becomes vassal to end planet
            dragStartBubble.vassalTo = endBubble;
          } else {
            // End planet becomes vassal to start planet
            endBubble.vassalTo = dragStartBubble;
          }
          
          // Don't send ships immediately for vassal establishment
          dragStartBubble = null;
          dragEndPos = null;
          isDraggingRightClick = false;
          isDraggingMiddleClick = false;
          return;
        } else {
          // Middle click to non-allied base: send 50%
          amountToSend = Math.floor(dragStartBubble.microBubbles / 2);
        }
      } else if (isDraggingRightClick) {
        // Right click: send 100% - 1
        amountToSend = Math.max(0, dragStartBubble.microBubbles - 1);
      } else {
        // Left click: smart send (target + bonus, keep 1 at home)
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isOwnPlanet = endBubble.className.includes('player1');
        
        if (isOwnPlanet) {
          // Sending to own planet: send 50%
          amountToSend = Math.floor(dragStartBubble.microBubbles / 2);
        } else {
          const targetShips = endBubble.microBubbles;
          const isNeutral = endBubble.className.includes('neutral');
          const isTurret = endBubble.isTurret;
          const isZapper = endBubble.isZapper;
          
          // Calculate bonus based on travel time and growth rate
          let bonusAmount;
          if (isNeutral || isTurret || isZapper) {
            bonusAmount = 1; // Neutrals, turrets, and black holes don't grow
          } else {
            // Calculate distance and travel time
            const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
            const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
            const targetBubbleX = parseInt(endBubble.style.left) + parseInt(endBubble.style.width) / 2;
            const targetBubbleY = parseInt(endBubble.style.top) + parseInt(endBubble.style.height) / 2;
            const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
            const travelTimeMs = (distance / SHIP_SPEED) * 1000;
            
            // Estimate ships to send (iterative approach)
            let estimatedShips = targetShips + Math.ceil(travelTimeMs / endBubble.growthRate);
            // Account for launch delay: last ship arrives at travelTime + SHIP_RELEASE_DELAY * (estimatedShips - 1)
            const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
            const totalTimeMs = travelTimeMs + launchDelayMs;
            
            // Calculate how many ships the target will generate during total time
            const shipsGenerated = Math.ceil(totalTimeMs / endBubble.growthRate);
            bonusAmount = Math.max(1, shipsGenerated) + 1; // At least 1, +1 extra for enemy planets to account for last-second growth
          }
          
          const idealSend = targetShips + bonusAmount;

          // Only send if we have enough ships for the calculated amount
          if (maxWeCanSend >= idealSend) {
            amountToSend = idealSend;
          }
          // If we don't have enough ships, don't send anything
        }
      }

      // Only send if amountToSend > 0
      if (amountToSend > 0) {
        sendMicroBubbles(dragStartBubble, endBubble, false, false, amountToSend);
      }
    }
    
    dragStartBubble = null;
    dragEndPos = null;
    isDraggingRightClick = false;
    isDraggingMiddleClick = false;
  }
});

document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});

document.addEventListener('auxclick', (e) => {
  if (e.button === 1) {
    e.preventDefault();
  }
});

document.addEventListener('wheel', (e) => {
  // Find bubble under mouse
  const hoveredBubble = bubbles.find(bubble => {
    const rect = bubble.getBoundingClientRect();
    return e.clientX >= rect.left && e.clientX <= rect.right &&
           e.clientY >= rect.top && e.clientY <= rect.bottom;
  });
  
  // If hovering a vassal planet owned by player
  if (hoveredBubble && hoveredBubble.vassalTo && hoveredBubble.className.includes('player1')) {
    e.preventDefault();
    
    if (e.deltaY < 0) {
      // Wheel up: increase minimum
      hoveredBubble.vassalMinimum += 1;
    } else if (e.deltaY > 0) {
      // Wheel down: decrease minimum (minimum of 1)
      hoveredBubble.vassalMinimum = Math.max(1, hoveredBubble.vassalMinimum - 1);
    }
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (startScreen.style.display === 'none') {
      startScreen.style.display = 'flex';
      gameStarted = false;
    } else {
      startScreen.style.display = 'none';
      gameStarted = true;
    }
  } else if (e.key === ' ' && !e.repeat) { // Spacebar for diaspora
    e.preventDefault();
    // Check if mouse is over a planet
    const hoveredPlanet = bubbles.find(planet => {
      const rect = planet.getBoundingClientRect();
      return mouseX >= rect.left && mouseX <= rect.right &&
             mouseY >= rect.top && mouseY <= rect.bottom;
    });

    if (hoveredPlanet && hoveredPlanet.className.includes('player1')) {
      performDiaspora(hoveredPlanet);
    }
  }
});

function performDiaspora(sourcePlanet) {
  // Find all 0-ship bases that can be captured (not owned by player1)
  const zeroShipBases = [
    // Planets with 0 ships
    ...bubbles.filter(planet =>
      planet !== sourcePlanet &&
      !planet.className.includes('player1') &&
      planet.microBubbles === 0
    ),
    // Zappers with 0 ships
    ...zappers.filter(zapper =>
      zapper !== sourcePlanet &&
      !zapper.className.includes('player1') &&
      zapper.microBubbles === 0
    ),
    // Turrets with 0 ships
    ...laserTurrets.filter(turret =>
      turret !== sourcePlanet &&
      !turret.className.includes('player1') &&
      turret.microBubbles === 0
    )
  ];

  if (zeroShipBases.length === 0) return;

  // Sort by priority: bigger planets first, then smaller planets, then zappers, then turrets
  zeroShipBases.sort((a, b) => {
    // Determine type priority: planets > zappers > turrets
    const aType = a.className.includes('bubble') ? 3 : (a.className.includes('zapper') ? 2 : 1);
    const bType = b.className.includes('bubble') ? 3 : (b.className.includes('zapper') ? 2 : 1);

    if (aType !== bType) {
      return bType - aType; // Higher type number first
    }

    // Same type: sort by size (bigger first)
    const aSize = parseInt(a.style.width);
    const bSize = parseInt(b.style.width);
    return bSize - aSize;
  });

  let shipsRemaining = sourcePlanet.microBubbles - 1; // Keep 1 ship at home

  for (const targetBase of zeroShipBases) {
    if (shipsRemaining <= 0) break;

    // Send 1 ship to capture this 0-ship base
    const shipsNeeded = 1;

    if (shipsNeeded <= shipsRemaining) {
      sendMicroBubbles(sourcePlanet, targetBase, false, false, shipsNeeded);
      shipsRemaining -= shipsNeeded;
    }
  }
}


window.addEventListener('resize', () => {
  backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
  backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;
});

newGameButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(false);
});

restartButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(true);
});


startGameButton.addEventListener('click', () => {
  startScreen.style.display = 'none';
  gameStarted = true;
});

pauseRestartButton.addEventListener('click', () => {
  initializeGame(true); // true = restart same map
  startScreen.style.display = 'none';
  gameStarted = true;
});

createStartScreenBubbles();
initializeGame(false);
gameLoop();
</script>
</body></html>