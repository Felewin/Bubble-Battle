<html><head><base href="https://bubblebattle.ocean/">
<title>Bubble Battle - Underwater Strategy</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: linear-gradient(135deg, #0077be, #00305a);
    color: #fff;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  #backgroundCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  #uiCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .bubble {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.3);
    cursor: default;
    transition: all 0.3s ease;
    opacity: 0.8;
  }
  .bubble.player1 {
    cursor: pointer;
  }
  .bubble.player1:hover {
    transform: scale(1.02);
    opacity: 1;
  }
  .player1 { background: radial-gradient(circle at 30% 30%, #7fff7f, #00a000); }
  .player2 { background: radial-gradient(circle at 30% 30%, #ff69b4, #c71585); }
  .neutral { background: radial-gradient(circle at 30% 30%, #b0e0e6, #4682b4); }
  .microBubble {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.9);
  }
  #victoryScreen, #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #victoryMessage, #gameTitle {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px #00ff00;
    margin-bottom: 30px;
  }
  .gameButton {
    font-size: 24px;
    padding: 10px 20px;
    background-color: #00a000;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 10px;
  }
  .gameButton:hover {
    background-color: #00c000;
    transform: scale(1.1);
  }
  #controlsExplanation {
    max-width: 600px;
    text-align: center;
    margin-bottom: 30px;
    font-size: 18px;
    line-height: 1.5;
  }
</style>
</head>
<body>
<canvas id="backgroundCanvas"></canvas>
<canvas id="gameCanvas"></canvas>
<canvas id="uiCanvas"></canvas>
<audio id="sendSound" src="bubble_release.wav"></audio>
<audio id="captureSound" src="bubble_pop.wav"></audio>
<div id="startScreen" style="display: none;">
  <h1 id="gameTitle">Bubble Battle</h1>
  <div id="controlsExplanation">
    <p>Controls:</p>
    <p>Left Click Drag, Middle Click Drag, Right Click Drag</p>
    <p>Capture enemy (pink) and neutral (blue) bubbles to expand your aquatic empire!</p>
    <p>Press ESC to close this menu</p>
  </div>
  <button id="startGameButton" class="gameButton">Resume Game</button>
</div>
<div id="victoryScreen" style="display: none;">
  <div id="victoryMessage">Victory!</div>
  <button id="restartButton" class="gameButton">Restart</button>
  <button id="newGameButton" class="gameButton">New Game</button>
</div>
<script>
const backgroundCanvas = document.getElementById('backgroundCanvas');
const backgroundCtx = backgroundCanvas.getContext('2d');
const gameCanvas = document.getElementById('gameCanvas');
const gameCtx = gameCanvas.getContext('2d');
const uiCanvas = document.getElementById('uiCanvas');
const uiCtx = uiCanvas.getContext('2d');
const sendSound = document.getElementById('sendSound');
const captureSound = document.getElementById('captureSound');
const victoryScreen = document.getElementById('victoryScreen');
const startScreen = document.getElementById('startScreen');
const newGameButton = document.getElementById('newGameButton');
const restartButton = document.getElementById('restartButton');
const startGameButton = document.getElementById('startGameButton');

backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;

let bubbles = [];
let microBubbles = [];
let dragStartBubble = null;
let dragEndPos = null;
let plankton = [];
let isDraggingRightClick = false;
let isDraggingMiddleClick = false;
let gameState = [];
let gameStarted = true;
let startScreenBubbles = [];
let hoveredBubble = null;

const SHIP_SPEED = 75; // pixels per second (doubled from 37.5)
const SHIP_RADIUS = 3; // Radius of the ship (half of its width)
const SHIP_RELEASE_DELAY = (SHIP_RADIUS * 2 / SHIP_SPEED) * 1000 * 1.5; // 1.5 times longer delay between ship releases

function createBubble(x, y, size, owner, microBubbles) {
  const bubble = document.createElement('div');
  bubble.className = `bubble ${owner}`;
  bubble.style.left = `${x}px`;
  bubble.style.top = `${y}px`;
  bubble.style.width = `${size}px`;
  bubble.style.height = `${size}px`;
  bubble.microBubbles = microBubbles || Math.floor(Math.random() * 50) + 10;
  bubble.innerHTML = bubble.microBubbles;
  bubble.growthRate = Math.floor(400000 / (size * 3));
  bubble.lastGrowth = Date.now();
  bubble.isReleasing = false;
  bubble.releasingCount = 0;
  bubble.lastReleasedShipTime = 0;
  
  const fontSize = Math.max(12, Math.min(24, size / 4));
  bubble.style.fontSize = `${fontSize}px`;
  
  bubble.addEventListener('mousedown', (e) => {
    if (!bubble.isReleasing && bubble.className.includes('player1')) {
      if (e.button === 0) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
      } else if (e.button === 2) {
        dragStartBubble = bubble;
        isDraggingRightClick = true;
        isDraggingMiddleClick = false;
      } else if (e.button === 1) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = true;
      }
    }
    e.preventDefault();
  });
  
  document.body.appendChild(bubble);
  bubbles.push(bubble);
}

function sendMicroBubbles(from, to, sendAll = false, sendOne = false) {
  let microBubblesToSend;
  if (sendOne) {
    microBubblesToSend = from.microBubbles >= 1 ? 1 : 0;
  } else if (sendAll) {
    microBubblesToSend = from.microBubbles;
  } else {
    microBubblesToSend = Math.floor(from.microBubbles / 2);
  }
  
  // Ensure we don't send more than the planet currently has
  microBubblesToSend = Math.min(microBubblesToSend, from.microBubbles);
  
  if (microBubblesToSend === 0) return;
  
  sendSound.play();
  from.isReleasing = true;
  from.releasingCount = microBubblesToSend;
  
  const fromX = parseInt(from.style.left) + parseInt(from.style.width) / 2;
  const fromY = parseInt(from.style.top) + parseInt(from.style.height) / 2;
  const toX = parseInt(to.style.left) + parseInt(to.style.width) / 2;
  const toY = parseInt(to.style.top) + parseInt(to.style.height) / 2;
  const dx = toX - fromX;
  const dy = toY - fromY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const duration = distance / SHIP_SPEED;
  
  function releaseNextShip() {
    if (from.releasingCount > 0 && from.microBubbles > 0) {
      const currentTime = Date.now();
      if (currentTime - from.lastReleasedShipTime >= SHIP_RELEASE_DELAY) {
        from.microBubbles -= 1;
        from.innerHTML = from.microBubbles;
        from.releasingCount -= 1;
        from.lastReleasedShipTime = currentTime;
        
        if (from.releasingCount === 0 || from.microBubbles === 0) {
          from.isReleasing = false;
        }
        
        const microBubble = document.createElement('div');
        microBubble.className = 'microBubble';
        microBubble.style.left = `${fromX}px`;
        microBubble.style.top = `${fromY}px`;
        microBubble.style.backgroundColor = from.className.includes('player1') ? '#00a000' : '#c71585';
        document.body.appendChild(microBubble);
        
        microBubbles.push({
          element: microBubble,
          target: to,
          startTime: currentTime,
          duration: duration * 1000,
          fromX: fromX,
          fromY: fromY,
          toX: toX,
          toY: toY,
          owner: from.className.includes('player1') ? 'player1' : 'player2'
        });
      }
      requestAnimationFrame(releaseNextShip);
    } else {
      from.isReleasing = false;
    }
  }
  
  releaseNextShip();
}

function updateMicroBubbles() {
  microBubbles = microBubbles.filter(microBubble => {
    const progress = (Date.now() - microBubble.startTime) / microBubble.duration;
    if (progress >= 1) {
      document.body.removeChild(microBubble.element);
      return false;
    }
    
    const currentX = microBubble.fromX + (microBubble.toX - microBubble.fromX) * progress;
    const currentY = microBubble.fromY + (microBubble.toY - microBubble.fromY) * progress;
    
    microBubble.element.style.left = `${currentX}px`;
    microBubble.element.style.top = `${currentY}px`;
    
    const bubbleCenterX = parseInt(microBubble.target.style.left) + parseInt(microBubble.target.style.width) / 2;
    const bubbleCenterY = parseInt(microBubble.target.style.top) + parseInt(microBubble.target.style.height) / 2;
    const bubbleRadius = parseInt(microBubble.target.style.width) / 2;
    
    const distanceToBubble = Math.sqrt((currentX - bubbleCenterX) ** 2 + (currentY - bubbleCenterY) ** 2);
    
    if (distanceToBubble <= bubbleRadius) {
      document.body.removeChild(microBubble.element);
      if (microBubble.target.className.includes(microBubble.owner)) {
        microBubble.target.microBubbles += 1;
      } else {
        microBubble.target.microBubbles -= 1;
        if (microBubble.target.microBubbles <= 0) {
          microBubble.target.microBubbles = 1;
          microBubble.target.className = `bubble ${microBubble.owner}`;
          captureSound.play();
        }
      }
      microBubble.target.innerHTML = microBubble.target.microBubbles;
      checkVictory();
      return false;
    }
    
    return true;
  });
}

function updateBubbles() {
  const now = Date.now();
  bubbles.forEach(bubble => {
    if (!bubble.className.includes('neutral')) {
      if (now - bubble.lastGrowth >= bubble.growthRate) {
        bubble.microBubbles += 1;
        bubble.innerHTML = bubble.microBubbles;
        bubble.lastGrowth = now;
      }
    }
  });

  // Enemy AI logic
  const enemyPlanets = bubbles.filter(b => b.className.includes('player2'));
  const otherPlanets = bubbles.filter(b => !b.className.includes('player2'));

  enemyPlanets.forEach(enemyPlanet => {
    if (!enemyPlanet.isReleasing && enemyPlanet.microBubbles > 0) {
      const target = otherPlanets.find(p => p.microBubbles < enemyPlanet.microBubbles);
      if (target) {
        const microBubblesToSend = Math.min(enemyPlanet.microBubbles - 1, Math.floor(enemyPlanet.microBubbles / 2));
        sendMicroBubbles(enemyPlanet, target, false, false);
      }
    }
  });
}

function createPlankton() {
  for (let i = 0; i < 50; i++) {
    plankton.push({
      x: Math.random() * gameCanvas.width,
      y: Math.random() * gameCanvas.height,
      size: Math.random() * 2 + 1,
      speedX: (Math.random() - 0.5) * 0.5,
      speedY: (Math.random() - 0.5) * 0.5,
      angle: Math.random() * Math.PI * 2
    });
  }
}

function drawPlankton() {
  gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  gameCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  plankton.forEach(p => {
    gameCtx.beginPath();
    gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    gameCtx.fill();
    
    p.angle += (Math.random() - 0.5) * 0.1;
    p.x += Math.cos(p.angle) * p.speedX;
    p.y += Math.sin(p.angle) * p.speedY;
    
    if (p.x < 0) p.x = gameCanvas.width;
    if (p.x > gameCanvas.width) p.x = 0;
    if (p.y < 0) p.y = gameCanvas.height;
    if (p.y > gameCanvas.height) p.y = 0;
  });
}

function drawSquadronLines() {
  // Draw glowing lines for each squadron in transit
  // Group microBubbles by unique routes to draw one line per squadron
  const routes = new Map();
  
  microBubbles.forEach(mb => {
    const key = `${mb.fromX},${mb.fromY}-${mb.toX},${mb.toY}-${mb.owner}`;
    if (!routes.has(key)) {
      routes.set(key, { fromX: mb.fromX, fromY: mb.fromY, toX: mb.toX, toY: mb.toY, owner: mb.owner });
    }
  });
  
  routes.forEach(route => {
    const color = route.owner === 'player1' ? '0, 160, 0' : '199, 21, 133'; // Green for player1, pink for player2
    
    // Find the source and target bubbles to get their radii
    const sourceBubble = bubbles.find(b => {
      const centerX = parseInt(b.style.left) + parseInt(b.style.width) / 2;
      const centerY = parseInt(b.style.top) + parseInt(b.style.height) / 2;
      return Math.abs(centerX - route.fromX) < 1 && Math.abs(centerY - route.fromY) < 1;
    });
    
    const targetBubble = bubbles.find(b => {
      const centerX = parseInt(b.style.left) + parseInt(b.style.width) / 2;
      const centerY = parseInt(b.style.top) + parseInt(b.style.height) / 2;
      return Math.abs(centerX - route.toX) < 1 && Math.abs(centerY - route.toY) < 1;
    });
    
    if (!sourceBubble || !targetBubble) return;
    
    const sourceRadius = parseInt(sourceBubble.style.width) / 2;
    const targetRadius = parseInt(targetBubble.style.width) / 2;
    
    // Calculate direction vector
    const dx = route.toX - route.fromX;
    const dy = route.toY - route.fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return;
    
    // Normalize direction vector
    const ndx = dx / distance;
    const ndy = dy / distance;
    
    // Calculate edge points
    const startX = route.fromX + ndx * sourceRadius;
    const startY = route.fromY + ndy * sourceRadius;
    const endX = route.toX - ndx * targetRadius;
    const endY = route.toY - ndy * targetRadius;
    
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    
    // Outer glow
    gameCtx.strokeStyle = `rgba(${color}, 0.1)`;
    gameCtx.lineWidth = 8;
    gameCtx.stroke();
    
    // Inner line
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    gameCtx.strokeStyle = `rgba(${color}, 0.3)`;
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
}

function drawArrow() {
  uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
  
  if (dragStartBubble && dragEndPos) {
    // Check if the dragStartBubble is still owned by the player
    if (!dragStartBubble.className.includes('player1')) {
      dragStartBubble = null;
      dragEndPos = null;
      isDraggingRightClick = false;
      isDraggingMiddleClick = false;
      return;
    }

    const startX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
    const startY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
    const endX = dragEndPos.x;
    const endY = dragEndPos.y;
    
    // Find bubble under mouse cursor
    hoveredBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
             dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
    });
    
    // Determine arrow color based on drag type and conditions
    let arrowColor;
    let microBubblesToSend;
    let showNumbers = true;
    let displayFormula = '';
    
    if (isDraggingMiddleClick) {
      // Middle click: Blue
      arrowColor = 'rgba(0, 100, 255, 0.7)';
      microBubblesToSend = dragStartBubble.microBubbles >= 1 ? 1 : 0;
    } else if (isDraggingRightClick) {
      // Right click (50%): Yellow
      arrowColor = 'rgba(255, 255, 0, 0.7)';
      microBubblesToSend = Math.floor(dragStartBubble.microBubbles / 2);
      displayFormula = '50%';
    } else {
      // Left click: smart send - always keep 1 at home
      if (hoveredBubble && hoveredBubble !== dragStartBubble) {
        const targetShips = hoveredBubble.microBubbles;
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        
        if (maxWeCanSend > targetShips) {
          // We can send target + extra
          const idealSend = targetShips + 5;
          microBubblesToSend = Math.min(maxWeCanSend, idealSend);
          const bonus = microBubblesToSend - targetShips;
          displayFormula = `${targetShips} + ${bonus}`;
          arrowColor = microBubblesToSend >= targetShips + 5 ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
        } else {
          // We can't beat them, send everything - 1
          microBubblesToSend = Math.max(0, maxWeCanSend);
          displayFormula = '100% - 1';
          arrowColor = 'rgba(255, 0, 0, 0.7)';
        }
      } else {
        showNumbers = false;
        arrowColor = 'rgba(255, 255, 255, 0.5)';
      }
    }
    
    uiCtx.beginPath();
    uiCtx.moveTo(startX, startY);
    uiCtx.lineTo(endX, endY);
    uiCtx.strokeStyle = arrowColor;
    uiCtx.lineWidth = 2;
    uiCtx.stroke();
    
    const angle = Math.atan2(endY - startY, endX - startX);
    uiCtx.beginPath();
    uiCtx.moveTo(endX, endY);
    uiCtx.lineTo(endX- 15 * Math.cos(angle - Math.PI / 6), endY - 15 * Math.sin(angle - Math.PI / 6));
    uiCtx.lineTo(endX - 15 * Math.cos(angle + Math.PI / 6), endY - 15 * Math.sin(angle + Math.PI / 6));
    uiCtx.closePath();
    uiCtx.fillStyle = arrowColor;
    uiCtx.fill();

    if (showNumbers) {
      uiCtx.font = '16px Arial';
      uiCtx.fillStyle = 'white';
      uiCtx.textAlign = 'center';
      uiCtx.textBaseline = 'middle';
      
      // Show formula above the number
      if (displayFormula) {
        uiCtx.fillText(displayFormula, (startX + endX) / 2, (startY + endY) / 2 - 20);
      }
      
      uiCtx.fillText(microBubblesToSend.toString(), (startX + endX) / 2, (startY + endY) / 2);
    }
  }
}

function gameLoop() {
  if (!gameStarted) {
    drawStartScreen();
  } else {
    drawBackground();
    drawPlankton();
    drawSquadronLines();
    drawArrow();
    updateMicroBubbles();
    updateBubbles();
  }
  requestAnimationFrame(gameLoop);
}

function drawBackground() {
  const gradient = backgroundCtx.createRadialGradient(
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, 0,
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, Math.max(backgroundCanvas.width, backgroundCanvas.height) / 2
  );
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
}

function drawStartScreen() {
  const gradient = backgroundCtx.createLinearGradient(0, 0, 0, backgroundCanvas.height);
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

  updateStartScreenBubbles();
  drawStartScreenBubbles();
}

function createStartScreenBubbles() {
  for (let i = 0; i < 200; i++) {
    startScreenBubbles.push({
      x: Math.random() * backgroundCanvas.width,
      y: backgroundCanvas.height + Math.random() * backgroundCanvas.height,
      size: Math.random() * 60 + 10,
      speed: Math.random() * 1.5 + 0.5,
      color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 0.5 + 0.3})`,
      wobbleSpeed: Math.random() * 0.02 + 0.01,
      wobbleAmount: Math.random() * 2 + 1
    });
  }
}

function updateStartScreenBubbles() {
  startScreenBubbles.forEach(bubble => {
    bubble.y -= bubble.speed;
    bubble.x += Math.sin(Date.now() * bubble.wobbleSpeed) * bubble.wobbleAmount;
    if (bubble.y + bubble.size < 0) {
      bubble.y = backgroundCanvas.height + bubble.size;
      bubble.x = Math.random() * backgroundCanvas.width;
    }
  });
}

function drawStartScreenBubbles() {
  backgroundCtx.save();
  backgroundCtx.globalCompositeOperation = 'lighter';
  startScreenBubbles.forEach(bubble => {
    backgroundCtx.beginPath();
    backgroundCtx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
    const gradient = backgroundCtx.createRadialGradient(
      bubble.x, bubble.y, 0,
      bubble.x, bubble.y, bubble.size
    );
    gradient.addColorStop(0, bubble.color);
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    backgroundCtx.fillStyle = gradient;
    backgroundCtx.fill();
  });
  backgroundCtx.restore();
}

function isOverlapping(x, y, size) {
  const minDistance = 40;
  for (const bubble of bubbles) {
    const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
    const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
    const bubbleSize = parseInt(bubble.style.width);
    const distance = Math.sqrt((x - bubbleX) ** 2 + (y - bubbleY) ** 2);
    if (distance < (size + bubbleSize) / 2 + minDistance) {
      return true;
    }
  }
  return false;
}

function initializeGame(restartSameMap = false) {
  bubbles.forEach(bubble => document.body.removeChild(bubble));
  bubbles = [];
  
  // Remove all ships (microBubbles) that have been sent from any planet
  microBubbles.forEach(mb => document.body.removeChild(mb.element));
  microBubbles = [];
  
  plankton = [];
  
  // Clear all commands of ships to be sent
  dragStartBubble = null;
  dragEndPos = null;
  isDraggingRightClick = false;
  isDraggingMiddleClick = false;
  
  const maxSize = 99 * 4;
  const minSize = 40;
  const padding = 10;

  let attempts = 0;
  const maxAttempts = 1000;

  const enemyCount = Math.floor(Math.random() * 3) + 2;
  const neutralCount = 10 - enemyCount - 1;

  if (restartSameMap && gameState.length > 0) {
    gameState.forEach(bubble => {
      createBubble(bubble.x, bubble.y, bubble.size, bubble.owner, bubble.microBubbles);
    });
  } else {
    for (let i = 0; i < 10; i++) {
      let x, y, size;
      attempts = 0;
      do {
        size = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
        x = Math.floor(Math.random() * (window.innerWidth - size - 2 * padding)) + padding;
        y = Math.floor(Math.random() * (window.innerHeight - size - 2 * padding)) + padding;
        attempts++;
        if (attempts > maxAttempts) {
          console.log("Could not place all bubbles without overlap");
          break;
        }
      } while (isOverlapping(x + size / 2, y + size / 2, size));
    
      if (attempts <= maxAttempts) {
        let owner;
        if (i === 0) {
          owner = 'player1';
        } else if (i < 1 + enemyCount) {
          owner = 'player2';
        } else {
          owner = 'neutral';
        }
        createBubble(x, y, size, owner);
      }
    }

    gameState = bubbles.map(bubble => ({
      x: parseInt(bubble.style.left),
      y: parseInt(bubble.style.top),
      size: parseInt(bubble.style.width),
      owner: bubble.className.split(' ')[1],
      microBubbles: bubble.microBubbles
    }));
  }

  // Ensure player doesn't start with less than more than one enemy
  const playerBubble = bubbles.find(b => b.className.includes('player1'));
  const enemyBubbles = bubbles.filter(b => b.className.includes('player2'));
  
  if (playerBubble && enemyBubbles.length > 0) {
    // Sort enemies by ship count descending
    const sortedEnemies = enemyBubbles.sort((a, b) => b.microBubbles - a.microBubbles);
    
    // Count how many enemies have more ships than player
    const strongerEnemies = sortedEnemies.filter(e => e.microBubbles > playerBubble.microBubbles);
    
    // If more than one enemy is stronger, boost player to match the second strongest
    if (strongerEnemies.length > 1) {
      playerBubble.microBubbles = strongerEnemies[1].microBubbles;
      playerBubble.innerHTML = playerBubble.microBubbles;
    }
  }

  createPlankton();
}

function checkVictory() {
  const player1Bubbles = bubbles.filter(bubble => bubble.className.includes('player1'));
  const player2Bubbles = bubbles.filter(bubble => bubble.className.includes('player2'));
  const player1MicroBubbles = microBubbles.filter(mb => mb.owner === 'player1');
  
  if (player2Bubbles.length === 0) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Victory!';
  } else if (player1Bubbles.length === 0 && player1MicroBubbles.length === 0) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Defeat!';
  }
}

document.addEventListener('mousemove', (e) => {
  if (dragStartBubble) {
    dragEndPos = { x: e.clientX, y: e.clientY };
  }
});

document.addEventListener('mouseup', (e) => {
  if ((e.button === 0 || e.button === 1 || e.button === 2) && dragStartBubble) {
    const endBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return e.clientX >= rect.left && e.clientX <= rect.right &&
             e.clientY >= rect.top && e.clientY <= rect.bottom;
    });

    if (endBubble && endBubble !== dragStartBubble) {
      sendMicroBubbles(dragStartBubble, endBubble, isDraggingRightClick, isDraggingMiddleClick);
    }
    
    dragStartBubble = null;
    dragEndPos = null;
    isDraggingRightClick = false;
    isDraggingMiddleClick = false;
  }
});

document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});

document.addEventListener('auxclick', (e) => {
  if (e.button === 1) {
    e.preventDefault();
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (startScreen.style.display === 'none') {
      startScreen.style.display = 'flex';
      gameStarted = false;
    } else {
      startScreen.style.display = 'none';
      gameStarted = true;
    }
  }
});

window.addEventListener('resize', () => {
  backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
  backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;
});

newGameButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(false);
});

restartButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(true);
});

startGameButton.addEventListener('click', () => {
  startScreen.style.display = 'none';
  gameStarted = true;
});

createStartScreenBubbles();
initializeGame(false);
gameLoop();
</script>
</body></html>