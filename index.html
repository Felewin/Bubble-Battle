<html><head><base href="https://bubblebattle.ocean/">
<title>Bubble Battle - Underwater Strategy</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: linear-gradient(135deg, #0077be, #00305a);
    color: #fff;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  #backgroundCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  #uiCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .bubble {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.3);
    cursor: default;
    transition: all 0.3s ease;
    opacity: 0.8;
  }
  .bubble.player1 {
    cursor: pointer;
  }
  .bubble.player1:hover {
    transform: scale(1.02);
    opacity: 1;
  }
  .player1 { background: radial-gradient(circle at 30% 30%, #7fff7f, #00a000); }
  .player2 { background: radial-gradient(circle at 30% 30%, #ff69b4, #c71585); }
  .neutral { background: radial-gradient(circle at 30% 30%, #b0e0e6, #4682b4); }
  .microBubble {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.9);
  }
  #victoryScreen, #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #victoryMessage, #gameTitle {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px #00ff00;
    margin-bottom: 30px;
  }
  .gameButton {
    font-size: 24px;
    padding: 10px 20px;
    background-color: #00a000;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 10px;
  }
  .gameButton:hover {
    background-color: #00c000;
    transform: scale(1.1);
  }
  #controlsExplanation {
    max-width: 600px;
    text-align: center;
    margin-bottom: 30px;
    font-size: 18px;
    line-height: 1.5;
  }
</style>
</head>
<body>
<canvas id="backgroundCanvas"></canvas>
<canvas id="gameCanvas"></canvas>
<canvas id="uiCanvas"></canvas>
<audio id="sendSound" src="bubble_release.wav"></audio>
<audio id="captureSound" src="bubble_pop.wav"></audio>
<div id="startScreen" style="display: none;">
  <h1 id="gameTitle">Bubble Battle</h1>
  <div id="controlsExplanation">
    <p>Controls:</p>
    <p>Left Click Drag, Middle Click Drag, Right Click Drag</p>
    <p>Capture enemy (pink) and neutral (blue) bubbles to expand your aquatic empire!</p>
    <p>Press ESC to close this menu</p>
  </div>
  <button id="startGameButton" class="gameButton">Resume Game</button>
</div>
<div id="victoryScreen" style="display: none;">
  <div id="victoryMessage">Victory!</div>
  <button id="restartButton" class="gameButton">Restart</button>
  <button id="newGameButton" class="gameButton">New Game</button>
</div>
<script>
const backgroundCanvas = document.getElementById('backgroundCanvas');
const backgroundCtx = backgroundCanvas.getContext('2d');
const gameCanvas = document.getElementById('gameCanvas');
const gameCtx = gameCanvas.getContext('2d');
const uiCanvas = document.getElementById('uiCanvas');
const uiCtx = uiCanvas.getContext('2d');
const sendSound = document.getElementById('sendSound');
const captureSound = document.getElementById('captureSound');
const victoryScreen = document.getElementById('victoryScreen');
const startScreen = document.getElementById('startScreen');
const newGameButton = document.getElementById('newGameButton');
const restartButton = document.getElementById('restartButton');
const startGameButton = document.getElementById('startGameButton');

backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;

let bubbles = [];
let microBubbles = [];
let dragStartBubble = null;
let dragEndPos = null;
let plankton = [];
let isDraggingRightClick = false;
let isDraggingMiddleClick = false;
let gameState = [];
let gameStarted = true;
let startScreenBubbles = [];
let hoveredBubble = null;
let passiveEnemiesMode = false;

const SHIP_SPEED = 75; // pixels per second (doubled from 37.5)
const SHIP_RADIUS = 3; // Radius of the ship (half of its width)
const SHIP_RELEASE_DELAY = (SHIP_RADIUS * 2 / SHIP_SPEED) * 1000 * 1.5; // 1.5 times longer delay between ship releases

function createBubble(x, y, size, owner, microBubbles) {
  const bubble = document.createElement('div');
  bubble.className = `bubble ${owner}`;
  bubble.style.left = `${x}px`;
  bubble.style.top = `${y}px`;
  bubble.style.width = `${size}px`;
  bubble.style.height = `${size}px`;
  bubble.microBubbles = microBubbles || Math.floor(Math.random() * 50) + 10;
  bubble.growthRate = Math.floor(400000 / (size * 3));
  bubble.lastGrowth = Date.now();
  bubble.isReleasing = false;
  bubble.releasingCount = 0;
  bubble.lastReleasedShipTime = 0;
  bubble.vassalTo = null; // Track if this planet is a vassal to another
  bubble.lastVassalSend = 0; // Track last time vassal sent a ship
  bubble.vassalMinimum = 1; // Minimum ships to keep before sending to master
  
  // Create wrapper for count displays to stack them vertically
  const countWrapper = document.createElement('div');
  countWrapper.style.display = 'flex';
  countWrapper.style.flexDirection = 'column';
  countWrapper.style.alignItems = 'center';
  countWrapper.style.position = 'relative';
  countWrapper.style.zIndex = '1';
  bubble.appendChild(countWrapper);
  
  // Create count display element
  const countDisplay = document.createElement('div');
  countDisplay.textContent = bubble.microBubbles;
  countWrapper.appendChild(countDisplay);
  bubble.countDisplay = countDisplay;
  
  // Create vassal minimum display element
  const vassalMinDisplay = document.createElement('div');
  vassalMinDisplay.style.fontSize = '0.7em';
  vassalMinDisplay.style.color = 'rgb(100, 150, 255)';
  vassalMinDisplay.style.marginTop = '2px';
  vassalMinDisplay.style.display = 'none';
  countWrapper.appendChild(vassalMinDisplay);
  bubble.vassalMinDisplay = vassalMinDisplay;
  
  // Create overlay element for showing required ships
  const overlay = document.createElement('div');
  overlay.className = 'bubble-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '-20px';
  overlay.style.left = '50%';
  overlay.style.transform = 'translateX(-50%)';
  overlay.style.fontSize = '16px';
  overlay.style.fontWeight = 'bold';
  overlay.style.color = 'rgba(0, 255, 100, 0.9)';
  overlay.style.textShadow = '0 0 3px rgba(0, 0, 0, 0.7), 1px 1px 2px rgba(0, 0, 0, 0.7)';
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = '10';
  bubble.appendChild(overlay);
  bubble.overlay = overlay;
  
  const fontSize = Math.max(12, Math.min(24, size / 4));
  bubble.style.fontSize = `${fontSize}px`;
  
  bubble.addEventListener('mousedown', (e) => {
    if (!bubble.isReleasing && bubble.className.includes('player1')) {
      if (e.button === 0) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
      } else if (e.button === 2) {
        dragStartBubble = bubble;
        isDraggingRightClick = true;
        isDraggingMiddleClick = false;
      } else if (e.button === 1) {
        dragStartBubble = bubble;
        isDraggingRightClick = false;
        isDraggingMiddleClick = true;
      }
    }
    e.preventDefault();
  });
  
  document.body.appendChild(bubble);
  bubbles.push(bubble);
}

function sendMicroBubbles(from, to, sendAll = false, sendOne = false, specificAmount = null) {
  let microBubblesToSend;
  if (specificAmount !== null) {
    microBubblesToSend = specificAmount;
  } else if (sendOne) {
    microBubblesToSend = from.microBubbles >= 1 ? 1 : 0;
  } else if (sendAll) {
    microBubblesToSend = Math.floor(from.microBubbles / 2);
  } else {
    microBubblesToSend = from.microBubbles;
  }
  
  // Ensure we don't send more than the planet currently has
  microBubblesToSend = Math.min(microBubblesToSend, from.microBubbles);
  
  if (microBubblesToSend === 0) return;
  
  sendSound.play();
  
  // Immediately decrement the full amount from the planet
  from.microBubbles -= microBubblesToSend;
  from.countDisplay.textContent = from.microBubbles;
  
  from.isReleasing = true;
  from.releasingCount = microBubblesToSend;
  
  const fromX = parseInt(from.style.left) + parseInt(from.style.width) / 2;
  const fromY = parseInt(from.style.top) + parseInt(from.style.height) / 2;
  const toX = parseInt(to.style.left) + parseInt(to.style.width) / 2;
  const toY = parseInt(to.style.top) + parseInt(to.style.height) / 2;
  const dx = toX - fromX;
  const dy = toY - fromY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const duration = distance / SHIP_SPEED;
  
  // Create unique squadron ID for this send command
  const squadronId = `squad_${Date.now()}_${Math.random()}`;
  
  // Store the owner at launch time so it doesn't change if planet is conquered
  const squadronOwner = from.className.includes('player1') ? 'player1' : 'player2';
  const squadronColor = squadronOwner === 'player1' ? '#00a000' : '#c71585';
  
  function releaseNextShip() {
    if (from.releasingCount > 0) {
      const currentTime = Date.now();
      if (currentTime - from.lastReleasedShipTime >= SHIP_RELEASE_DELAY) {
        from.releasingCount -= 1;
        from.lastReleasedShipTime = currentTime;
        
        if (from.releasingCount === 0) {
          from.isReleasing = false;
        }
        
        const microBubble = document.createElement('div');
        microBubble.className = 'microBubble';
        microBubble.style.left = `${fromX}px`;
        microBubble.style.top = `${fromY}px`;
        microBubble.style.backgroundColor = squadronColor;
        document.body.appendChild(microBubble);
        
        microBubbles.push({
          element: microBubble,
          target: to,
          startTime: currentTime,
          duration: duration * 1000,
          fromX: fromX,
          fromY: fromY,
          toX: toX,
          toY: toY,
          owner: squadronOwner,
          squadronId: squadronId,
          totalInSquadron: microBubblesToSend,
          remainingToLaunch: from.releasingCount
        });
      }
      requestAnimationFrame(releaseNextShip);
    } else {
      from.isReleasing = false;
    }
  }
  
  releaseNextShip();
}

function updateMicroBubbles() {
  microBubbles = microBubbles.filter(microBubble => {
    const progress = (Date.now() - microBubble.startTime) / microBubble.duration;
    if (progress >= 1) {
      document.body.removeChild(microBubble.element);
      return false;
    }
    
    const currentX = microBubble.fromX + (microBubble.toX - microBubble.fromX) * progress;
    const currentY = microBubble.fromY + (microBubble.toY - microBubble.fromY) * progress;
    
    microBubble.element.style.left = `${currentX}px`;
    microBubble.element.style.top = `${currentY}px`;
    
    const bubbleCenterX = parseInt(microBubble.target.style.left) + parseInt(microBubble.target.style.width) / 2;
    const bubbleCenterY = parseInt(microBubble.target.style.top) + parseInt(microBubble.target.style.height) / 2;
    const bubbleRadius = parseInt(microBubble.target.style.width) / 2;
    
    const distanceToBubble = Math.sqrt((currentX - bubbleCenterX) ** 2 + (currentY - bubbleCenterY) ** 2);
    
    if (distanceToBubble <= bubbleRadius) {
      document.body.removeChild(microBubble.element);
      if (microBubble.target.className.includes(microBubble.owner)) {
        microBubble.target.microBubbles += 1;
      } else {
        microBubble.target.microBubbles -= 1;
        if (microBubble.target.microBubbles <= 0) {
          microBubble.target.microBubbles = 1;
          const oldOwner = microBubble.target.className.split(' ')[1];
          microBubble.target.className = `bubble ${microBubble.owner}`;
          
          // Clear vassal relationships when ownership changes
          microBubble.target.vassalTo = null;
          microBubble.target.vassalMinimum = 1;
          // Also clear if this planet was anyone's master
          bubbles.forEach(b => {
            if (b.vassalTo === microBubble.target) {
              b.vassalTo = null;
              b.vassalMinimum = 1;
            }
          });
          
          captureSound.play();
        }
      }
      microBubble.target.countDisplay.textContent = microBubble.target.microBubbles;
      checkVictory();
      return false;
    }
    
    return true;
  });
}

function updateBubbles() {
  const now = Date.now();
  bubbles.forEach(bubble => {
    if (!bubble.className.includes('neutral')) {
      if (now - bubble.lastGrowth >= bubble.growthRate) {
        bubble.microBubbles += 1;
        bubble.countDisplay.textContent = bubble.microBubbles;
        bubble.lastGrowth = now;
      }
    }
    
    // Update vassal minimum display
    if (bubble.vassalTo && bubbles.includes(bubble.vassalTo)) {
      bubble.vassalMinDisplay.style.display = 'block';
      bubble.vassalMinDisplay.textContent = `(${bubble.vassalMinimum})`;
    } else {
      bubble.vassalMinDisplay.style.display = 'none';
    }
    
    // Handle vassal behavior
    if (bubble.vassalTo && bubble.microBubbles > bubble.vassalMinimum && !bubble.isReleasing) {
      // Check if vassal is still valid (both planets exist, both owned by player, and master is still player1)
      if (bubbles.includes(bubble.vassalTo) && 
          bubble.className.includes('player1') && 
          bubble.vassalTo.className.includes('player1')) {
        // Send one ship at a time, keeping vassalMinimum at home
        const timeSinceLastSend = now - bubble.lastVassalSend;
        if (timeSinceLastSend >= SHIP_RELEASE_DELAY) {
          sendMicroBubbles(bubble, bubble.vassalTo, false, false, 1);
          bubble.lastVassalSend = now;
        }
      } else {
        // Clear invalid vassal relationship
        bubble.vassalTo = null;
        bubble.vassalMinimum = 1;
      }
    }
  });

  // Enemy AI logic (skip if in passive enemies mode)
  if (!passiveEnemiesMode) {
    const enemyPlanets = bubbles.filter(b => b.className.includes('player2'));
    const otherPlanets = bubbles.filter(b => !b.className.includes('player2'));

    enemyPlanets.forEach(enemyPlanet => {
      if (!enemyPlanet.isReleasing && enemyPlanet.microBubbles > 0) {
        const target = otherPlanets.find(p => p.microBubbles < enemyPlanet.microBubbles);
        if (target) {
          const microBubblesToSend = Math.min(enemyPlanet.microBubbles - 1, Math.floor(enemyPlanet.microBubbles / 2));
          sendMicroBubbles(enemyPlanet, target, false, false);
        }
      }
    });
  }
}

function createPlankton() {
  for (let i = 0; i < 50; i++) {
    plankton.push({
      x: Math.random() * gameCanvas.width,
      y: Math.random() * gameCanvas.height,
      size: Math.random() * 2 + 1,
      speedX: (Math.random() - 0.5) * 0.5,
      speedY: (Math.random() - 0.5) * 0.5,
      angle: Math.random() * Math.PI * 2
    });
  }
}

function drawVassalLines() {
  const time = Date.now() / 1000; // Time in seconds for animation
  
  bubbles.forEach(bubble => {
    if (bubble.vassalTo && bubbles.includes(bubble.vassalTo)) {
      const vassalX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
      const vassalY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
      const masterX = parseInt(bubble.vassalTo.style.left) + parseInt(bubble.vassalTo.style.width) / 2;
      const masterY = parseInt(bubble.vassalTo.style.top) + parseInt(bubble.vassalTo.style.height) / 2;
      
      // Calculate distance and direction
      const dx = masterX - vassalX;
      const dy = masterY - vassalY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance === 0) return;
      
      // Draw animated sine wave
      gameCtx.beginPath();
      gameCtx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
      gameCtx.lineWidth = 2;
      
      const segments = 50;
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const x = vassalX + dx * t;
        const y = vassalY + dy * t;
        
        // Calculate perpendicular offset for sine wave
        const perpX = -dy / distance;
        const perpY = dx / distance;
        
        // Animate the sine wave by subtracting time offset (flows from vassal to master)
        const waveOffset = Math.sin(t * Math.PI * 4 - time * 3) * 10;
        const finalX = x + perpX * waveOffset;
        const finalY = y + perpY * waveOffset;
        
        if (i === 0) {
          gameCtx.moveTo(finalX, finalY);
        } else {
          gameCtx.lineTo(finalX, finalY);
        }
      }
      
      gameCtx.stroke();
    }
  });
}

function drawPlankton() {
  gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  gameCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  plankton.forEach(p => {
    gameCtx.beginPath();
    gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    gameCtx.fill();
    
    p.angle += (Math.random() - 0.5) * 0.1;
    p.x += Math.cos(p.angle) * p.speedX;
    p.y += Math.sin(p.angle) * p.speedY;
    
    if (p.x < 0) p.x = gameCanvas.width;
    if (p.x > gameCanvas.width) p.x = 0;
    if (p.y < 0) p.y = gameCanvas.height;
    if (p.y > gameCanvas.height) p.y = 0;
  });
  
  // Draw rippling corona on capturable planets during left click drag
  if (dragStartBubble && !isDraggingRightClick && !isDraggingMiddleClick) {
    const time = Date.now();
    bubbles.forEach(bubble => {
      if (bubble === dragStartBubble) return;
      
      // Calculate if we have enough to capture this planet
      const targetShips = bubble.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      const isNeutral = bubble.className.includes('neutral');
      
      let bonusAmount;
      if (isNeutral) {
        bonusAmount = 1;
      } else if (bubble.className.includes('player2')) {
        const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
        const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
        const targetBubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const targetBubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
        const travelTimeMs = (distance / SHIP_SPEED) * 1000;
        let estimatedShips = targetShips + Math.ceil(travelTimeMs / bubble.growthRate);
        const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
        const totalTimeMs = travelTimeMs + launchDelayMs;
        const shipsGenerated = Math.ceil(totalTimeMs / bubble.growthRate);
        bonusAmount = Math.max(1, shipsGenerated);
      } else {
        return; // Skip player's own planets
      }
      
      const idealSend = targetShips + bonusAmount;
      
      // Only highlight if we have enough
      if (maxWeCanSend >= idealSend) {
        const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const bubbleRadius = parseInt(bubble.style.width) / 2;
        
        // Create rippling corona effect
        for (let i = 0; i < 3; i++) {
          const phase = (time / 1000 + i * 0.4) % 1;
          const rippleRadius = bubbleRadius + 10 + phase * 20;
          const opacity = (1 - phase) * 0.3;
          
          gameCtx.beginPath();
          gameCtx.arc(bubbleX, bubbleY, rippleRadius, 0, Math.PI * 2);
          gameCtx.strokeStyle = `rgba(0, 255, 100, ${opacity})`;
          gameCtx.lineWidth = 3;
          gameCtx.stroke();
        }
      }
    });
  }
}

// Track last known positions of squadron labels and their HTML elements
const squadronLabelPositions = new Map();
const squadronLabelElements = new Map();

function drawSquadronCounts() {
  // Group microBubbles by squadron
  const squadrons = new Map();
  
  microBubbles.forEach(mb => {
    if (!squadrons.has(mb.squadronId)) {
      squadrons.set(mb.squadronId, []);
    }
    squadrons.get(mb.squadronId).push(mb);
  });
  
  squadrons.forEach((ships, squadronId) => {
    if (ships.length === 0) return;
    
    // Count ships in transit and to be launched
    const shipsInTransit = ships.length;
    // Get the most recent (minimum) remainingToLaunch value
    const shipsToLaunch = Math.min(...ships.map(s => s.remainingToLaunch));
    const totalCount = shipsInTransit + shipsToLaunch;
    
    // Skip singleton squadrons (1 ship total) - don't show label
    if (totalCount <= 1) return;
    
    // Find the leading bubble (furthest along in progress)
    let leadingShip = ships[0];
    let maxProgress = 0;
    
    ships.forEach(ship => {
      const progress = (Date.now() - ship.startTime) / ship.duration;
      if (progress > maxProgress) {
        maxProgress = progress;
        leadingShip = ship;
      }
    });
    
    // Calculate stopping point based on destination planet's edge
    const targetPlanet = leadingShip.target;
    const targetRadius = parseInt(targetPlanet.style.width) / 2;
    const totalDistance = Math.sqrt((leadingShip.toX - leadingShip.fromX) ** 2 + (leadingShip.toY - leadingShip.fromY) ** 2);
    // Buffer: planet radius + text height (20px) + offset above ship (10px) + margin (10px)
    const textBuffer = targetRadius + 40;
    const stopDistance = totalDistance - textBuffer;
    const maxProgressBeforePlanet = Math.max(0, stopDistance / totalDistance);
    
    // Calculate position of leading ship, capped to stop before destination planet
    const progress = Math.min((Date.now() - leadingShip.startTime) / leadingShip.duration, maxProgressBeforePlanet);
    const leadX = leadingShip.fromX + (leadingShip.toX - leadingShip.fromX) * progress;
    const leadY = leadingShip.fromY + (leadingShip.toY - leadingShip.fromY) * progress;
    
    // Get or initialize stored position
    if (!squadronLabelPositions.has(squadronId)) {
      squadronLabelPositions.set(squadronId, { x: leadX, y: leadY });
    }
    
    const storedPos = squadronLabelPositions.get(squadronId);
    
    // Only update position if we're moving forward (don't jump back)
    const dx = leadX - leadingShip.fromX;
    const dy = leadY - leadingShip.fromY;
    const currentDist = Math.sqrt(dx * dx + dy * dy);
    
    const storedDx = storedPos.x - leadingShip.fromX;
    const storedDy = storedPos.y - leadingShip.fromY;
    const storedDist = Math.sqrt(storedDx * storedDx + storedDy * storedDy);
    
    if (currentDist > storedDist) {
      storedPos.x = leadX;
      storedPos.y = leadY;
    }
    
    // Create or update HTML element for this squadron
    let labelElement = squadronLabelElements.get(squadronId);
    if (!labelElement) {
      labelElement = document.createElement('div');
      labelElement.style.position = 'absolute';
      labelElement.style.fontFamily = 'Arial';
      labelElement.style.fontSize = '20px';
      labelElement.style.fontWeight = 'bold';
      labelElement.style.textShadow = '0 0 4px rgba(0, 0, 0, 0.8), 1px 1px 3px rgba(0, 0, 0, 0.8)';
      labelElement.style.pointerEvents = 'none';
      labelElement.style.zIndex = '1000';
      labelElement.style.transform = 'translate(-50%, -100%)';
      document.body.appendChild(labelElement);
      squadronLabelElements.set(squadronId, labelElement);
    }
    
    // Update element position, content and color
    const color = leadingShip.owner === 'player1' ? 'rgb(0, 255, 100)' : 'rgb(255, 105, 180)';
    labelElement.style.color = color;
    labelElement.style.left = `${storedPos.x}px`;
    labelElement.style.top = `${storedPos.y - 10}px`;
    labelElement.textContent = totalCount.toString();
  });
  
  // Clean up positions and elements for squadrons that no longer exist
  const activeSquadronIds = new Set(squadrons.keys());
  for (const squadronId of squadronLabelPositions.keys()) {
    if (!activeSquadronIds.has(squadronId)) {
      squadronLabelPositions.delete(squadronId);
      const element = squadronLabelElements.get(squadronId);
      if (element && element.parentNode) {
        document.body.removeChild(element);
      }
      squadronLabelElements.delete(squadronId);
    }
  }
}

function drawSquadronLines() {
  // Draw glowing lines for each squadron in transit
  // Group microBubbles by unique routes to draw one line per squadron
  const routes = new Map();
  
  microBubbles.forEach(mb => {
    const key = `${mb.fromX},${mb.fromY}-${mb.toX},${mb.toY}-${mb.owner}`;
    if (!routes.has(key)) {
      routes.set(key, { fromX: mb.fromX, fromY: mb.fromY, toX: mb.toX, toY: mb.toY, owner: mb.owner });
    }
  });
  
  routes.forEach(route => {
    const color = route.owner === 'player1' ? '0, 160, 0' : '199, 21, 133'; // Green for player1, pink for player2
    
    // Find the source and target bubbles to get their radii
    const sourceBubble = bubbles.find(b => {
      const centerX = parseInt(b.style.left) + parseInt(b.style.width) / 2;
      const centerY = parseInt(b.style.top) + parseInt(b.style.height) / 2;
      return Math.abs(centerX - route.fromX) < 1 && Math.abs(centerY - route.fromY) < 1;
    });
    
    const targetBubble = bubbles.find(b => {
      const centerX = parseInt(b.style.left) + parseInt(b.style.width) / 2;
      const centerY = parseInt(b.style.top) + parseInt(b.style.height) / 2;
      return Math.abs(centerX - route.toX) < 1 && Math.abs(centerY - route.toY) < 1;
    });
    
    if (!sourceBubble || !targetBubble) return;
    
    const sourceRadius = parseInt(sourceBubble.style.width) / 2;
    const targetRadius = parseInt(targetBubble.style.width) / 2;
    
    // Calculate direction vector
    const dx = route.toX - route.fromX;
    const dy = route.toY - route.fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return;
    
    // Normalize direction vector
    const ndx = dx / distance;
    const ndy = dy / distance;
    
    // Calculate edge points
    const startX = route.fromX + ndx * sourceRadius;
    const startY = route.fromY + ndy * sourceRadius;
    const endX = route.toX - ndx * targetRadius;
    const endY = route.toY - ndy * targetRadius;
    
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    
    // Outer glow
    gameCtx.strokeStyle = `rgba(${color}, 0.1)`;
    gameCtx.lineWidth = 8;
    gameCtx.stroke();
    
    // Inner line
    gameCtx.beginPath();
    gameCtx.moveTo(startX, startY);
    gameCtx.lineTo(endX, endY);
    gameCtx.strokeStyle = `rgba(${color}, 0.3)`;
    gameCtx.lineWidth = 2;
    gameCtx.stroke();
  });
}

function drawArrow() {
  uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
  
  // Update bubble overlays during left click drag
  if (dragStartBubble && !isDraggingRightClick && !isDraggingMiddleClick) {
    bubbles.forEach(bubble => {
      if (bubble === dragStartBubble) {
        bubble.overlay.style.display = 'none';
        return;
      }
      
      // Calculate if we have enough to capture this planet
      const targetShips = bubble.microBubbles;
      const maxWeCanSend = dragStartBubble.microBubbles - 1;
      const isNeutral = bubble.className.includes('neutral');
      
      let bonusAmount;
      if (isNeutral) {
        bonusAmount = 1;
      } else if (bubble.className.includes('player2')) {
        const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
        const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
        const targetBubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
        const targetBubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
        const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
        const travelTimeMs = (distance / SHIP_SPEED) * 1000;
        let estimatedShips = targetShips + Math.ceil(travelTimeMs / bubble.growthRate);
        const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
        const totalTimeMs = travelTimeMs + launchDelayMs;
        const shipsGenerated = Math.ceil(totalTimeMs / bubble.growthRate);
        bonusAmount = Math.max(1, shipsGenerated);
      } else {
        bubble.overlay.style.display = 'none';
        return; // Skip player's own planets
      }
      
      const idealSend = targetShips + bonusAmount;
      
      // Only show count if we have enough
      if (maxWeCanSend >= idealSend) {
        bubble.overlay.textContent = idealSend.toString();
        bubble.overlay.style.display = 'block';
      } else {
        bubble.overlay.style.display = 'none';
      }
    });
  } else {
    // Hide all overlays when not dragging
    bubbles.forEach(bubble => {
      bubble.overlay.style.display = 'none';
    });
  }
  
  if (dragStartBubble && dragEndPos) {
    // Check if the dragStartBubble is still owned by the player
    if (!dragStartBubble.className.includes('player1')) {
      dragStartBubble = null;
      dragEndPos = null;
      isDraggingRightClick = false;
      isDraggingMiddleClick = false;
      return;
    }

    const startX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
    const startY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
    const endX = dragEndPos.x;
    const endY = dragEndPos.y;
    
    // Find bubble under mouse cursor
    hoveredBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return dragEndPos.x >= rect.left && dragEndPos.x <= rect.right &&
             dragEndPos.y >= rect.top && dragEndPos.y <= rect.bottom;
    });
    
    // Determine arrow color based on drag type and conditions
    let arrowColor;
    let microBubblesToSend;
    let showNumbers = true;
    let displayFormula = '';
    
    if (isDraggingMiddleClick) {
      // Middle click: Blue - establishing vassal relationship (no numbers shown)
      arrowColor = 'rgba(0, 100, 255, 0.7)';
      showNumbers = false;
    } else if (isDraggingRightClick) {
      // Right click (100% - 1): Yellow
      arrowColor = 'rgba(255, 255, 0, 0.7)';
      microBubblesToSend = Math.max(0, dragStartBubble.microBubbles - 1);
      displayFormula = '100% - 1';
    } else {
      // Left click: smart send - always keep 1 at home
      if (hoveredBubble && hoveredBubble !== dragStartBubble) {
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isOwnPlanet = hoveredBubble.className.includes('player1');
        
        if (isOwnPlanet) {
          // Sending to own planet: send 50%
          microBubblesToSend = Math.floor(dragStartBubble.microBubbles / 2);
          displayFormula = '50%';
          arrowColor = 'rgba(0, 255, 0, 0.7)';
        } else {
          const targetShips = hoveredBubble.microBubbles;
          const isNeutral = hoveredBubble.className.includes('neutral');
          
          // Calculate bonus based on travel time and growth rate
          let bonusAmount;
          if (isNeutral) {
            bonusAmount = 1; // Neutrals don't grow
          } else {
            // Calculate distance and travel time
            const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
            const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
            const targetBubbleX = parseInt(hoveredBubble.style.left) + parseInt(hoveredBubble.style.width) / 2;
            const targetBubbleY = parseInt(hoveredBubble.style.top) + parseInt(hoveredBubble.style.height) / 2;
            const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
            const travelTimeMs = (distance / SHIP_SPEED) * 1000;
            
            // Estimate ships to send (iterative approach)
            let estimatedShips = targetShips + Math.ceil(travelTimeMs / hoveredBubble.growthRate);
            // Account for launch delay: last ship arrives at travelTime + SHIP_RELEASE_DELAY * (estimatedShips - 1)
            const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
            const totalTimeMs = travelTimeMs + launchDelayMs;
            
            // Calculate how many ships the target will generate during total time
            const shipsGenerated = Math.ceil(totalTimeMs / hoveredBubble.growthRate);
            bonusAmount = Math.max(1, shipsGenerated); // At least 1
          }
          
          if (maxWeCanSend > targetShips) {
            // We can send target + extra
            const idealSend = targetShips + bonusAmount;
            microBubblesToSend = Math.min(maxWeCanSend, idealSend);
            const bonus = microBubblesToSend - targetShips;
            displayFormula = `${targetShips} + ${bonus}`;
            arrowColor = microBubblesToSend >= targetShips + bonusAmount ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
          } else {
            // We can't beat them, send everything - 1
            microBubblesToSend = Math.max(0, maxWeCanSend);
            displayFormula = '100% - 1';
            arrowColor = 'rgba(255, 0, 0, 0.7)';
          }
        }
      } else {
        showNumbers = false;
        arrowColor = 'rgba(255, 255, 255, 0.5)';
      }
    }
    
    uiCtx.beginPath();
    uiCtx.moveTo(startX, startY);
    uiCtx.lineTo(endX, endY);
    uiCtx.strokeStyle = arrowColor;
    uiCtx.lineWidth = 2;
    uiCtx.stroke();
    
    const angle = Math.atan2(endY - startY, endX - startX);
    uiCtx.beginPath();
    uiCtx.moveTo(endX, endY);
    uiCtx.lineTo(endX- 15 * Math.cos(angle - Math.PI / 6), endY - 15 * Math.sin(angle - Math.PI / 6));
    uiCtx.lineTo(endX - 15 * Math.cos(angle + Math.PI / 6), endY - 15 * Math.sin(angle + Math.PI / 6));
    uiCtx.closePath();
    uiCtx.fillStyle = arrowColor;
    uiCtx.fill();

    if (showNumbers) {
      uiCtx.font = '16px Arial';
      uiCtx.fillStyle = 'white';
      uiCtx.textAlign = 'center';
      uiCtx.textBaseline = 'middle';
      
      // Show formula above the number
      if (displayFormula) {
        uiCtx.fillText(displayFormula, (startX + endX) / 2, (startY + endY) / 2 - 20);
      }
      
      uiCtx.fillText(microBubblesToSend.toString(), (startX + endX) / 2, (startY + endY) / 2);
      
      // For left click smart send with enough ships, show percentage below
      if (!isDraggingMiddleClick && !isDraggingRightClick && hoveredBubble && hoveredBubble !== dragStartBubble) {
        const targetShips = hoveredBubble.microBubbles;
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isNeutral = hoveredBubble.className.includes('neutral');
        
        // Calculate bonus based on travel time and growth rate
        let bonusAmount;
        if (isNeutral) {
          bonusAmount = 1;
        } else {
          const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
          const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
          const targetBubbleX = parseInt(hoveredBubble.style.left) + parseInt(hoveredBubble.style.width) / 2;
          const targetBubbleY = parseInt(hoveredBubble.style.top) + parseInt(hoveredBubble.style.height) / 2;
          const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
          const travelTimeMs = (distance / SHIP_SPEED) * 1000;
          
          // Estimate ships to send (iterative approach)
          let estimatedShips = targetShips + Math.ceil(travelTimeMs / hoveredBubble.growthRate);
          // Account for launch delay
          const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
          const totalTimeMs = travelTimeMs + launchDelayMs;
          
          const shipsGenerated = Math.ceil(totalTimeMs / hoveredBubble.growthRate);
          bonusAmount = Math.max(1, shipsGenerated);
        }
        
        // Only show percentage if we have enough to send the bonus
        if (maxWeCanSend >= targetShips + bonusAmount) {
          const percentage = Math.round((microBubblesToSend / dragStartBubble.microBubbles) * 100);
          uiCtx.fillText(`(${percentage}%)`, (startX + endX) / 2, (startY + endY) / 2 + 20);
        }
      }
    }
  }
}

function gameLoop() {
  if (!gameStarted) {
    drawStartScreen();
  } else {
    drawBackground();
    drawPlankton();
    drawVassalLines();
    drawSquadronLines();
    drawSquadronCounts();
    drawArrow();
    updateMicroBubbles();
    updateBubbles();
  }
  requestAnimationFrame(gameLoop);
}

function drawBackground() {
  const gradient = backgroundCtx.createRadialGradient(
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, 0,
    backgroundCanvas.width / 2, backgroundCanvas.height / 2, Math.max(backgroundCanvas.width, backgroundCanvas.height) / 2
  );
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
}

function drawStartScreen() {
  const gradient = backgroundCtx.createLinearGradient(0, 0, 0, backgroundCanvas.height);
  gradient.addColorStop(0, '#00a8ff');
  gradient.addColorStop(1, '#004080');

  backgroundCtx.fillStyle = gradient;
  backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

  updateStartScreenBubbles();
  drawStartScreenBubbles();
}

function createStartScreenBubbles() {
  for (let i = 0; i < 200; i++) {
    startScreenBubbles.push({
      x: Math.random() * backgroundCanvas.width,
      y: backgroundCanvas.height + Math.random() * backgroundCanvas.height,
      size: Math.random() * 60 + 10,
      speed: Math.random() * 1.5 + 0.5,
      color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 0.5 + 0.3})`,
      wobbleSpeed: Math.random() * 0.02 + 0.01,
      wobbleAmount: Math.random() * 2 + 1
    });
  }
}

function updateStartScreenBubbles() {
  startScreenBubbles.forEach(bubble => {
    bubble.y -= bubble.speed;
    bubble.x += Math.sin(Date.now() * bubble.wobbleSpeed) * bubble.wobbleAmount;
    if (bubble.y + bubble.size < 0) {
      bubble.y = backgroundCanvas.height + bubble.size;
      bubble.x = Math.random() * backgroundCanvas.width;
    }
  });
}

function drawStartScreenBubbles() {
  backgroundCtx.save();
  backgroundCtx.globalCompositeOperation = 'lighter';
  startScreenBubbles.forEach(bubble => {
    backgroundCtx.beginPath();
    backgroundCtx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
    const gradient = backgroundCtx.createRadialGradient(
      bubble.x, bubble.y, 0,
      bubble.x, bubble.y, bubble.size
    );
    gradient.addColorStop(0, bubble.color);
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    backgroundCtx.fillStyle = gradient;
    backgroundCtx.fill();
  });
  backgroundCtx.restore();
}

function isOverlapping(x, y, size) {
  const minDistance = 40;
  for (const bubble of bubbles) {
    const bubbleX = parseInt(bubble.style.left) + parseInt(bubble.style.width) / 2;
    const bubbleY = parseInt(bubble.style.top) + parseInt(bubble.style.height) / 2;
    const bubbleSize = parseInt(bubble.style.width);
    const distance = Math.sqrt((x - bubbleX) ** 2 + (y - bubbleY) ** 2);
    if (distance < (size + bubbleSize) / 2 + minDistance) {
      return true;
    }
  }
  return false;
}

function initializeGame(restartSameMap = false, passiveEnemies = false) {
  // Stop all planets from releasing ships
  bubbles.forEach(bubble => {
    bubble.isReleasing = false;
    bubble.releasingCount = 0;
  });
  
  // Remove all bubbles
  bubbles.forEach(bubble => {
    if (bubble.parentNode) {
      document.body.removeChild(bubble);
    }
  });
  bubbles = [];
  
  // Remove all ships (microBubbles) that have been sent from any planet
  microBubbles.forEach(mb => {
    if (mb.element && mb.element.parentNode) {
      document.body.removeChild(mb.element);
    }
  });
  microBubbles = [];
  
  plankton = [];
  
  // Clear all commands of ships to be sent
  dragStartBubble = null;
  dragEndPos = null;
  isDraggingRightClick = false;
  isDraggingMiddleClick = false;
  
  // Set passive enemies mode
  passiveEnemiesMode = passiveEnemies;
  
  const maxSize = 99 * 4;
  const minSize = 40;
  const padding = 10;

  let attempts = 0;
  const maxAttempts = 1000;

  const enemyCount = passiveEnemies ? 9 : Math.floor(Math.random() * 3) + 2;
  const neutralCount = 10 - enemyCount - 1;

  if (restartSameMap && gameState.length > 0) {
    gameState.forEach(bubble => {
      createBubble(bubble.x, bubble.y, bubble.size, bubble.owner, bubble.microBubbles);
    });
  } else {
    for (let i = 0; i < 10; i++) {
      let x, y, size;
      attempts = 0;
      do {
        size = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
        x = Math.floor(Math.random() * (window.innerWidth - size - 2 * padding)) + padding;
        y = Math.floor(Math.random() * (window.innerHeight - size - 2 * padding)) + padding;
        attempts++;
        if (attempts > maxAttempts) {
          console.log("Could not place all bubbles without overlap");
          break;
        }
      } while (isOverlapping(x + size / 2, y + size / 2, size));
    
      if (attempts <= maxAttempts) {
        let owner;
        if (i === 0) {
          owner = 'player1';
        } else if (passiveEnemies) {
          owner = 'player2'; // All other planets are enemies in passive mode
        } else if (i < 1 + enemyCount) {
          owner = 'player2';
        } else {
          owner = 'neutral';
        }
        createBubble(x, y, size, owner);
      }
    }

    gameState = bubbles.map(bubble => ({
      x: parseInt(bubble.style.left),
      y: parseInt(bubble.style.top),
      size: parseInt(bubble.style.width),
      owner: bubble.className.split(' ')[1],
      microBubbles: bubble.microBubbles
    }));
  }

  // Ensure player doesn't start with less than more than one enemy
  const playerBubble = bubbles.find(b => b.className.includes('player1'));
  const enemyBubbles = bubbles.filter(b => b.className.includes('player2'));
  
  if (playerBubble && enemyBubbles.length > 0) {
    // Sort enemies by ship count descending
    const sortedEnemies = enemyBubbles.sort((a, b) => b.microBubbles - a.microBubbles);
    
    // Count how many enemies have more ships than player
    const strongerEnemies = sortedEnemies.filter(e => e.microBubbles > playerBubble.microBubbles);
    
    // If more than one enemy is stronger, boost player to match the second strongest
    if (strongerEnemies.length > 1) {
      playerBubble.microBubbles = strongerEnemies[1].microBubbles;
      playerBubble.countDisplay.textContent = playerBubble.microBubbles;
    }
  }

  createPlankton();
}

function checkVictory() {
  const player1Bubbles = bubbles.filter(bubble => bubble.className.includes('player1'));
  const player2Bubbles = bubbles.filter(bubble => bubble.className.includes('player2'));
  const player1MicroBubbles = microBubbles.filter(mb => mb.owner === 'player1');
  
  if (player2Bubbles.length === 0) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Victory!';
  } else if (player1Bubbles.length === 0 && player1MicroBubbles.length === 0) {
    victoryScreen.style.display = 'flex';
    document.getElementById('victoryMessage').textContent = 'Defeat!';
  }
}

document.addEventListener('mousemove', (e) => {
  if (dragStartBubble) {
    dragEndPos = { x: e.clientX, y: e.clientY };
  }
});

document.addEventListener('mouseup', (e) => {
  if ((e.button === 0 || e.button === 1 || e.button === 2) && dragStartBubble) {
    const endBubble = bubbles.find(bubble => {
      const rect = bubble.getBoundingClientRect();
      return e.clientX >= rect.left && e.clientX <= rect.right &&
             e.clientY >= rect.top && e.clientY <= rect.bottom;
    });

      if (endBubble && endBubble !== dragStartBubble) {
      // Calculate the amount to send based on drag type
      let amountToSend = null;
      
      if (isDraggingMiddleClick) {
        // Middle click: establish vassal relationship
        // Determine which is smaller
        const startSize = parseInt(dragStartBubble.style.width);
        const endSize = parseInt(endBubble.style.width);
        
        if (startSize < endSize) {
          // Start planet becomes vassal to end planet
          dragStartBubble.vassalTo = endBubble;
        } else {
          // End planet becomes vassal to start planet
          endBubble.vassalTo = dragStartBubble;
        }
        
        // Don't send ships immediately for middle click
        dragStartBubble = null;
        dragEndPos = null;
        isDraggingRightClick = false;
        isDraggingMiddleClick = false;
        return;
      } else if (isDraggingRightClick) {
        // Right click: send 100% - 1
        amountToSend = Math.max(0, dragStartBubble.microBubbles - 1);
      } else {
        // Left click: smart send (target + bonus, keep 1 at home)
        const maxWeCanSend = dragStartBubble.microBubbles - 1;
        const isOwnPlanet = endBubble.className.includes('player1');
        
        if (isOwnPlanet) {
          // Sending to own planet: send 50%
          amountToSend = Math.floor(dragStartBubble.microBubbles / 2);
        } else {
          const targetShips = endBubble.microBubbles;
          const isNeutral = endBubble.className.includes('neutral');
          
          // Calculate bonus based on travel time and growth rate
          let bonusAmount;
          if (isNeutral) {
            bonusAmount = 1; // Neutrals don't grow
          } else {
            // Calculate distance and travel time
            const startBubbleX = parseInt(dragStartBubble.style.left) + parseInt(dragStartBubble.style.width) / 2;
            const startBubbleY = parseInt(dragStartBubble.style.top) + parseInt(dragStartBubble.style.height) / 2;
            const targetBubbleX = parseInt(endBubble.style.left) + parseInt(endBubble.style.width) / 2;
            const targetBubbleY = parseInt(endBubble.style.top) + parseInt(endBubble.style.height) / 2;
            const distance = Math.sqrt((targetBubbleX - startBubbleX) ** 2 + (targetBubbleY - startBubbleY) ** 2);
            const travelTimeMs = (distance / SHIP_SPEED) * 1000;
            
            // Estimate ships to send (iterative approach)
            let estimatedShips = targetShips + Math.ceil(travelTimeMs / endBubble.growthRate);
            // Account for launch delay: last ship arrives at travelTime + SHIP_RELEASE_DELAY * (estimatedShips - 1)
            const launchDelayMs = SHIP_RELEASE_DELAY * (estimatedShips - 1);
            const totalTimeMs = travelTimeMs + launchDelayMs;
            
            // Calculate how many ships the target will generate during total time
            const shipsGenerated = Math.ceil(totalTimeMs / endBubble.growthRate);
            bonusAmount = Math.max(1, shipsGenerated); // At least 1
          }
          
          if (maxWeCanSend > targetShips) {
            const idealSend = targetShips + bonusAmount;
            amountToSend = Math.min(maxWeCanSend, idealSend);
          } else {
            amountToSend = Math.max(0, maxWeCanSend);
          }
        }
      }
      
      sendMicroBubbles(dragStartBubble, endBubble, false, false, amountToSend);
    }
    
    dragStartBubble = null;
    dragEndPos = null;
    isDraggingRightClick = false;
    isDraggingMiddleClick = false;
  }
});

document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});

document.addEventListener('auxclick', (e) => {
  if (e.button === 1) {
    e.preventDefault();
  }
});

document.addEventListener('wheel', (e) => {
  // Find bubble under mouse
  const hoveredBubble = bubbles.find(bubble => {
    const rect = bubble.getBoundingClientRect();
    return e.clientX >= rect.left && e.clientX <= rect.right &&
           e.clientY >= rect.top && e.clientY <= rect.bottom;
  });
  
  // If hovering a vassal planet owned by player
  if (hoveredBubble && hoveredBubble.vassalTo && hoveredBubble.className.includes('player1')) {
    e.preventDefault();
    
    if (e.deltaY < 0) {
      // Wheel up: increase minimum
      hoveredBubble.vassalMinimum += 1;
    } else if (e.deltaY > 0) {
      // Wheel down: decrease minimum (minimum of 1)
      hoveredBubble.vassalMinimum = Math.max(1, hoveredBubble.vassalMinimum - 1);
    }
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (startScreen.style.display === 'none') {
      startScreen.style.display = 'flex';
      gameStarted = false;
    } else {
      startScreen.style.display = 'none';
      gameStarted = true;
    }
  } else if (e.key === ' ') {
    // Spacebar: regenerate map with passive enemies
    e.preventDefault();
    initializeGame(false, true); // true = passiveEnemies mode
  }
});

window.addEventListener('resize', () => {
  backgroundCanvas.width = gameCanvas.width = uiCanvas.width = window.innerWidth;
  backgroundCanvas.height = gameCanvas.height = uiCanvas.height = window.innerHeight;
});

newGameButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(false);
});

restartButton.addEventListener('click', () => {
  victoryScreen.style.display = 'none';
  initializeGame(true);
});

startGameButton.addEventListener('click', () => {
  startScreen.style.display = 'none';
  gameStarted = true;
});

createStartScreenBubbles();
initializeGame(false);
gameLoop();
</script>
</body></html>